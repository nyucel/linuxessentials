\documentclass[10pt,a5paper]{book}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\begin{document}
\title{Linux'a Giriş}
\author{Z.Tuğçe Şirin\\
Mithat Göğebakan\\
Samet İlhan\\
Serdar Orazmamedov\\
Özcan Zafer Ayan\\
Emre Doğru\\
Sena Özben\\
Margulan Byekmurat\\
Sema Özvin\\
Ahmet Dellal\\
Emrah Şentürk\\
Ebru Akagündüz}
\renewcommand{\today}{December 13, 2012}
\renewcommand*\chaptername{Bölüm}
\maketitle
Linux Essentials is a new certification by the Linux Professional Institute (LPI) which is aimed especially at schools and universities in order to introduce children and young adults to Linux
\renewcommand*\contentsname{İçindekiler}
\tableofcontents
\listoftables
\chapter{Bilgisayarlar, Yazılım ve İşletim Sistemleri}
\paragraph{Amaçlar}
\begin{itemize}
 \item Temel bilgisayar donanım bilgisini edinmek
 \item Farklı işletim sistemlerinin farkında olmak ve bu sistemlerin farklı yönleri ile benzer yönlerini tayin etmek
 \end{itemize}
 
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Temel bilgisayar bilgisi işe yarar olacaktır.
 \end{itemize}

\begin{section}{Bilgisayar da neyin nesi?}
Bilgisayarın ne olduğunun ayrıntılarına girmeden önce, bilgisayar camiasının dikkate değer kişilerinden birkaç alıntı ile işe başlayalım.
\begin{quote}{Esasında Birleşik Devletler'de, gizlenmiş araştırma laboratuvarlarında yarım düzine kadar büyük bilgisayarlardan olsaydı; bu, ülke olarak ihtiyaç duyduğumuz şeylerin çaresine bakabilirdi. Howard H. Aiken, 1952}
\end{quote}
Howard Aiken bilgisayar alanında bir öncüydü ve IBM' nin ilk bilgisayarı "Harvard Mark I" in tasarımcısıydı. Modern anlayışa göre inşaa edilmiş ilk bilgisayarlar İkinci Dünya Savaşında şifrelenmiş mesajları deşifre etmek için ya da zor hesaplamaları yapmak için yapılmıştı; büyük, karmaşık ve hataya yatkınlardı. Bugünlerde bilgisayarlarda bulunan transistör ya da entegre devreler henüz icat edilmemişti. Bu zamanlarda aydınlığa kavuşan şey, savaşın hemen sonrasında ortaya çıkan birtakım temel varsayımlarla oluşturulan "bilgisayar" olarak kabul edilebilecek bir cihazın varlığıydı.
\begin{itemize}
 \item Bilgisayar veriyi 'otomatik olarak' çalıştırılan komutların sırasına göre işler,
 \item Programlar şartlı çalışmalara ve döngülere izin vermelidir,
 \item Bilgisayarın çalıştırdığı programı değiştirmek veya yerine başka bir şey yerleştirmek mümkün olmalıdır
 \end{itemize}

Örnek olarak, çoğu teknolojik cihaz - televizyon setlerinden dijital kameralara çamaşır makinesine ya da arabalara kadar - bugünlerde neredeyse küçük bir bilgisayar sayılabilecek programlanmış kontrol birimleri içerir. Böyle olmasına rağmen bu cihazları "bilgisayar" olarak görmeyiz, çünkü bu cihazlar sadece düzenlenmiş ve değiştirilemez programları çalıştırırlar.  Buna karşın bir hesap makinesi "verileri işlemek" için kullanılabilir ama - eğer "programlanabilir bir hesap makinesi" kadar pahalı değilse - bu otomatik olarak olmaz; bir insan tuşlara basmalıdır.

1950' nin başlarında, bilgisayarlar insanların ancak araştırma kurumlarında görmeyi bekleyeceği – Aiken'in öngördüğü gibi- yüksek derecede özelleştirilmiş cihazlardı. Zamanın bilim-kurgu filmleri gizemli dönen çarklarla dolu dolapların olduğu koridorları gösteriyordu. Tam olarak 70 yıl bile olmadan bu görüntü önemli bir ölçüde değişti. 
\footnote{Bu metinde belirtilen alıntının aslında Thomas J. Watson, IBM' in CEO' su, 1943' te “Dünya pazarında sadece beş bilgisayar için yer vardır.” sözleriyle birlikte söylendiği tasvir edilir. Ne yazık ki bu hiçbir zaman doğrulanamamıştır. Ve eğer 1943' te gerçekten bunu söylediyse, bu en azından 10 yıl için geçerli olurdu.}
\begin{quote}
{Kimsenin evinde bir bilgisayara sahip olmasına gerek yoktur. Ken Olsen, 1977}
\end{quote}

Ken Olsen bir bilgisayar üreticisi olan ve 1970' lerdeki “küçük” kavramının “havalandırmalı bir makine odasına ve güç ünitesine ihtiyaç duymayan ve bir milyon dolardan daha ucuza mal olan” anlamına geldiği zamanlarda “küçük” bilgisayarların geliştirilmesinde öncü bir firma olan  DEC (Digital Equipment Corporation) \footnote{DEC 1998 yılında Compaq tarafından alındı, Compaq ise 2002' de Hewlett-Packard tarafından alındı.} firmasının yöneticisi idi. Donanım teknolojisinin gelişmesiyle 1970' lerin sonuna doğru “küçük” kavramı “iki insan tarafından taşınabilir” anlamına gelmeye başladı.

DEC Linux camiası için önemlidir çünkü Unix - kendi oluşumundan 20 yıl sonra Linus Torvald' a Linux' u başlatmak için ilham veren sistem - ilk olarak DEC PDP-8 ve PDP-11 bilgisayarları üzerinde geliştirilmiştir.

Ayrıca 1970'ler ilk “ev bilgisayarları” nın varlığını gördü. Bu günümüzün kişisel bilgisayarlarıyla karşılaştırılamaz çünkü insanlar evde kendileri bilgisayarlarını lehimlemek durumundaydı (ki bu zamanlarda fiziksel olarak imkansız bir durum olurdu) ve bu bilgisayarlar çok nadir olarak kullanılabilir bir klavye ve iyi bir ekran ile geliyordu. Bu bilgisayarlar genellikle bir tamircinin eski kullandığı malzemelerden yapılıyordu, bir elektrikli tren setinden geriye kalanlar gibi, çünkü gerçekte çok kullanışlı değillerdi. Buna rağmen, bizim önceden yaptığımız tanımımıza göre “bilgisayar” olarak adlandırılıyorlardı çünkü özgürce programlanabiliyorlardı, bu zahmetli bir şekilde her şeyi tuşlardan girmek ya da (eğer o kadar şanslıysanız) bir ses kaset teypinden yüklemek anlamına gelse bile. Yine de bu bilgisayarlar tümüyle ciddiye alınmıyorlardı ve Ken Olsen'in cümlesi sık sık yanlış yorumlandı. O hiçbir şekilde küçük bilgisayarlara karşı değildi (hatta işi bu bilgisayarları satmaktı). Onun anlamadığı şey bütün ev işlerinin (ısıtma, aydınlatma, eğlence ve bunun gibi şeyler) bir bilgisayar tarafından kontrol edilmesi fikriydi – bu fikir o zamanlar sadece teoride vardı ama günümüzde oldukça uygulanabilir bir durumda.

1970' lerin sonunda ve 1980' lerde “ev bilgisayarları” parçalar topluluğundan kullanmaya hazır  cihazlara (“Apple II” ya da“Commodore 64” gibi isimler hala bu işin içinde olan eski üyelerimize tanıdık gelebilir) dönüştü ve ofislerde de bu cihazlardan bulunmaya başladı. IBM tarafından ilk kişisel bilgisayar 1981' de duyruldu ve Apple ilk “Macintosh” u 1984' te piyasaya sundu. Bunların dışındakiler ,söylenildiği gibi, tarihte kaldı ama bilgisayar dünyasının sadece kişisel bilgisayarlardan ya da Mac' lerden oluşmadığı unutulmamalıdır.  Devasa, odaları dolduran eski bilgisayarlar hala bulunmaktadır ama bu durum gitgide azalmakta ve büyük gruplarda günümüz bilgisayarlarından oluşmaktadır. Bununla birlikte temel ilke Howard Aiken' in zamanında beri değişmedi: Bilgisayarlar hala veriyi koşul ve döngüler içerebilen değişebilir programlara göre otomatik olarak işleyen cihazlardır. Ve işler bu şekilde yürümeye devam edecek gibi görünüyor.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item İlk kullandığınız bilgisayar neydi? Ne çeşit işlemci içeriyordu, ne kadar RAM'i vardı ve sabit diski ne kadar büyüktü (eğer bir sabit diski bulunuyorduysa - eğer sabit diski bulunmuyorduysa veri nasıl kalıcı olarak depolanıyordu)?
\end{itemize}}
\end{section}

\begin{section}{Bir Bilgisayarın Parçaları}

Hadi bir bilgisayarın (ya da daha açık olmak gerekirse IBM-uyumlu bir kişisel bilgisisayarın) içine bakma fırsatını yakalayalım ve burada bulmamızın mümkün olduğu parçaları inceleyelim:
\paragraph{İşlemci}{İşlemci (“CPU” Türkçe anlamıyla “Merkezi İşlem Ünitesi”) bilgisayarın çekirdeğidir: Burada bilgisayarı bilgisayar yapan, program kontrolündeki verilerin işlendiği yerdir. Bugünün işlemcileri genelde birkaç "çekirdek" içerir, bunun anlamı işlemcinin ana parçaları birden fazladır ve bağımsız olarak (bağımsız işlem yapabilme bilgisayarın işlem hızını ve buna bağlı olarak performansını arttırır) işlem yapabilirler.  Genelde hızlı bilgisayarlar birden fazla işlemci içerirler. Bilgisayarlar normalde Intel ya da AMD işlemcilerine (detaylarda farklılık gösterebilir ama aynı programları çalıştırabilirler) sahiptir. Tabletler ve akıllı telefonlar genel olarak ARM işlemcilerini kullanırlar. Bunlar diğerleri kadar güçlü değildirler ama enerjiyi daha az tüketirler. Intel ve AMD işlemcileri direkt olarak ARM için hazırlanmış programları çalıştıramazlar, aynı durum ARM işlemcileri içinde geçerlidir.}
\paragraph{Bellek}{Bir bilgisayarın çalışma belleğine “RAM” (ya da random-access memory/rastgele erişimli bellek, buradaki rastgele bir gelişigüzelliği değil isteğe bağlı erişimi ifade eder) denir. Bu bellekte sadece işlenen veriyi değil aynı zamanda çalıştırılan programın kodunu tutar.}

Bu fikir Howard Aiken' in döneminden bilgisayarın öncülerinden olan John von Neumann' a aittir. Kod ve veri arasında hiç farklılığın olmadığını öngörür – bu programların bizim adresleri ya da yemek tariflerini değiştirdiğimiz gibi kodu değiştirebileceği anlamına gelir. (Eski günlerde, programlar kabloların yeri değiştirilerek ya da delikli kartlar oluşturularak yazılırdı ve bu programlar değiştirilemezdi.)

Bugünün bilgisayarları normalde 1 gibibyte bellek belki de daha fazlasını kullanıyor. 1 gibibyte 2**30'a eşdeğerdir, bu 1,073,741,824 
\footnote{İnsanlar genelde bunu “gigabyte” olarak söyler ama gigabyte normalden yüzde 7 daha azdır.}
byte eder ve gerçekten çok büyük bir sayıdır. Karşılaştırma olarak düşünürsek: Harry Potter ve Ölüm Yadigarları kitabı her sayfa karakter, boşluk ve noktalama işaretlerinden oluşan 1700 karakterden fazla olmak üzere yaklaşık olarak 600 sayfa içerir. Bu muhtemel olarak bir milyon karakter demektir. Bununla birlikte bir gibibyte 1,000 tane Harry Potter kitabına tekabül eder ve eğer sadece genç bir büyücünün kahramanlıkları ile ilgili değilseniz 1,000 kitap inanılmaz bir kütüphane oluşturur.
\paragraph{Ekran kartı}{Çok uzak olmayan bir geçmişte insanlar bilgisayarlarda bir çıktıyı oluşturmak için elektrikli bir daktiloyu kullanabiliyorsa mutlulardı. Eski ev bilgisayarları televizyon setlerine bağlılardı ve genelde berbat denilebilecek resimler oluştururlardı. Diğer elde ise bugün en basit “akıllı telefonlar” bile oldukça etkileyici grafikler sunuyorlar ve şu anda kullanılan kişisel bilgisayarlardaki ekran kartları 1990' larda 
\footnote{Bu arada bütün teşekkürler harika bilgisayar oyunlarının tükenmeyen popülerliğine gitsin. Kim bilgisayar oyunlarının işe yaramaz olduğunu düşünüyorsa bir dakikasını bunun üstünde düşünerek geçirmelidir.}
pahalı bir spor arabaya ve küçük bir ev değerinde bir maliyete sahip olurdu. Bugünün sloganı “3D hızlandırma”, ki bu durumda ekran gerçekte 3D olarak çalışmaz (ki bu bile gitgitde moda olmaya başladı) bilgisayarın içinde işlenen grafikler sadece sağ, sol, yukarı ve aşağıyı içermez – bilgisayar ekranında görülebilen yönler- aynı zamanda ön ve geri kısımları içerir. Görüntü gerçeklik oyunları için bir canavarın bir duvarın önünden mi arkasından mı çıkacağı çok önemlidir bununla birlikte görünür olsun ya da olmasın modern ekran kartlarının amacı bilgisayar işlemcisini diğer işler için serbest bırakmaktır.  Güncel ekran kartları kendi işlemcilerine sahiptir, bunlar bilgisayarın kendi işlemcilerinden daha hızlı çalışırlar ama onlar kadar genel olarak kullanışlı değildirler.}

Çoğu bilgisayar ayrı bir ekran kartı içermez çünkü bu bilgisayarların grafik donanımları işlemcinin bir parçasıdır. Bu bilgisayarı daha küçük, ucuz, sessiz yapar ve bunlar enerjiyi daha iyi kullanır ama grafik performancı çok iyi değildir. Eğer en yeni oyunları oynama bağımlısı değilseniz bu sizin için gerçek bir sorun teşkil etmez.
\paragraph{Anakart}{Anakart genel olarak dikdörtgen biçimindedir, bilgisayarın işlemcisinin, RAM' inin ve grafik kartının takılı olduğu ve örneğin hard disklerin, yazıcıların, bir klavyenin ve farenin ya da ağ kablolarının ve elektronik olarak gerekli olan her şeyin kontrolcüsünün bulunduğu bir levhadır. Bilgisayarlarda bulunan anakartlar birçok çeşitli boy ve renklerde 
\footnote{Gerçekten! Ama yinede kimse bilgisayarının anakartını rengine göre seçmemelidir.}
olabilir, örneğin oturma odasında bulunan bir video kaydedici olarak kullanılan küçük ve sessiz bir bilgisayarın anakartı ile çok fazla RAM'e ihtiyaç duyan ve birden fazla işlemcisi bulunan büyük sunucuların anakartları farklı boyut ve renklerde olabilir.}
\paragraph{Güç Kaynağı}{Bir bilgisayar çalışmak için elektriğe ihtiyaç duyar, ne kadar elektriğe ihtiyaç duyduğu sahip olduğu bileşenlere bağlıdır. Güç kaynağı 240 V AC kaynağını bilgisayarın ihtiyaç duyduğu daha düşük değerlerdeki DC voltajına indirmek için kullanılır. Bütün parçalar için yeterli elektriği üretecek şekilde seçilmelidir. Güç kaynağının bilgisayara verdiği elektriğin çoğu er ya da geç ısıya dönüşecektir bu yüzden bilgisayarlarda soğutma çok önemlidir. Basit tasarımlarda, genelde bir ya da iki fan pahalı elektronik parçalara hava üfler ya da sıcak havayı dışarı atar. Uygun bir tasarımla bilgisayarları fana ihtiyaç duymayacak şekilde yapmak mümkündür bu şekilde bilgisayarlar çok sesssiz çalışırlar ama bu tür bilgisayarlar hem oldukça pahalı hem de çok hızlı değillerdir. (İşlemci ve ekran kartların hızlı olması genelde sıcak olması anlamına gelir.)}
\paragraph{Sabit Diskler}{Bilgisayarın belleği anlık çalışan süreçlerin (belgeler, dökümanlar, web sayfaları, geliştirilen programlar, müzik ve videolar,... - ve tabiki verinin üzerinde çalışan programlar) verilerinin depolandığı bir yerken kullanılmayan veriler sabit diskte depolanır. Bunun ana sebebi sabit diskler genelde bilgisayarların belleklerinden çok daha fazla veri depolayabilir – günümüzde sabit diskler terabytelar cinsinden ölçülmektedir.}

Boyuttaki bu genişleme hızda yavaşlama ile doğru orantılı ilerler. Bellek erişim zamanı nanosaniyeler ile ölçülürken sabit disklerde bu durum milisaniyelerle ölçülür. Bu bir metre ile 1000 kilometre arasındaki farkla eşdeğerdir.

Geleneksel olarak, sabit diskler manyetik madde içeren dönen plakalar içerir. Okuma / yazma kafası bu maddeyi değişik yerlerden manyetize edebilir ve depolanmış verileri okuyabilir. Bu plakalar dakikada 4,500 ile 15,000 defa döner ve okuma/yazma kafası ile plaka arası bir dakikadır (en fazla3 nanosaniye). Bu sabit disklerin çok hassas olduğu anlamına gelir, çünkü eğer okuma/yazma kafası disk hala çalışırken plaka ile iletişime geçerse kesintiye uğramış kafa kırılır ve disk bozulur.

Taşınabilir bilgisayarlar için olan son moda sabit diskler bilgisayarın düştüğünü anlayabilecek ve o anda sabit diskte oluşabilecek zararı önlemek için bilgisayarı kapatacak hızlandırılmış sensörlere sahiptirler.

Son moda SSD'ler ya da katı-durum diskleri, manyetik plakalar kullanmak yerine depolamak için “flash belleği” kullanır – bu içindekileri elektrik olmadan tutan bir RAM çeşididir. Katı-durum diskleri manyetik sabit disklerden daha hızlıdır fakat görece olarak daha pahalıdırlar. Bununla birlikte hareket eden bir parçaları yoktur, düşmeye dayanıklıdırlar, sabit disklere göre enerjiyi tasarruflu kullanırlar. Bu özellikleri taşınabilir bilgisayarlar için çok iyidir.

Flash bellekler belirli sayıda yazma işlemine tabii tutulabilir. Ölçümler bunun pratikte bir sorun teşkil etmediğini göstermiştir.

Bir sabit diski (manyetik ya da SSD) bilgisayara bağlamak için çeşitli yöntemler vardır. Şu anda en kullanılanı “serial ATA” (SATA) olarak adlandırılır, ayrıca “IDE” olarak da bilinir. Ayrıca sunucular SCSI ya da SAS disklerini kullanırlar. Harici diskler için, birisi USB ya da eSATA (SATA nın sağlam bağlantısı noktası olanı) kullanır.

Sözü açılmışken: Gigabytelar ile gibibytelar (ya da terabytelar ile tebibytelar arasında) arasındaki fark en çok sabit disklerde fark edilir. Örneğin 100 GB disk alırsınız ama bilgisayarınıza bağladığınızda bir bakarsınız 93 GB görünüyor?! Bununla birlikte diskiniz arızalı değildir (çok şanlısınız) disk sürücüsünü üreten firma gigabyteları kullanırken bilgisayarınız muhtemel olarak alanları gibibyte cinsinden hesaplıyordur.
\paragraph{Optik Sürücüler}{Sabit disklerin dışında bilgisayarlar genelde okuma ve genelde yazma işlemlerini yapabilen optik sürücüleri içerirler. (CD-ROM, DVD-ROM ve Blu-ray diskler) Mobil cihazlar bazen optik sürücüler için yeterli fiziksel hacme sahip olmazlar ama bu optik sürücüleri desteklemedikleri anlamına gelmez. Optik medyalar – isim verilere erişmek için kullanılan lazerden gelir- genellikle yazılım ve ürünlerin (müzik ya da filmlerin) dağıtımında kullanılırlar. Bu medyaların dağıtımı için İnternet etkin olarak kullanılmaya başladığı için optik medyaların önemi azalmaktadır.}
Eski zamanlarda optik medyalar yedekleme için kullanılıyordu ama bugünlerde bu çok anlamsızdır çünkü CD-ROM ortalama olarak 700 MB lık ve DVD-ROM ortalama olarak 9 GiB veri tutabilirler. Bu sebeple tam bir yedekleme 1 TBlık bir veri için 1000 CD ya da 100 DVD gerekir. (Blu-ray diskler 25 GB a kadar veri tutabilir fakat blu-ray diskleri okuyan okuyucu mekanizmalar oldukça pahalıdır.)
\paragraph{Ekran}{Eski filmlerde hala yeşil renkli bilgisayar ekranlarını görebilirsiniz. Gerçekte yeşil ekranların hepsi ortadan kaybolmuş durumdadır, renkler oldukça gözde bir durumdalar ve yeni ekranlar eskiden sahip olduğumuz CRT ler (tüplü monitörler) gibi devasa değiller. Sıvı kristal (LCD) teknolojisine dayanan ince ve şık monitörlere sahibiz artık. LCD' ler kendilerini masada daha az yer kaplamanın avantajıyla sınırlamıyorlar, aynı şekilde ekran ışıkları titreşmiyor ve kullanıcıları muhtemel zararlı radyasyonlara maruz bırakmıyor. Buna her yönden kazanma durumu da diyebiliriz.  Değişik açılardan bakıldığında renk değişikliklerinin olması ve ucuz cihazlarda kötü ışık durumları birkaç dezavantajı bulunur.}

Tüplü monitörlerde kullanılmayan bir resmin uzun bir süre ekranda kalmamasına dikkat edilirdi çünkü resim ekrana yazılabilir ve kalıcı bulanık bir fon olarak ekranda kalabilirdi. Ekran koruyucular belirli bir süre ekran kullanılmadığında şirin bir canlandırma ekrana gelir ve bu “yazılma” sorununu engellerdi. (klasik olan bir akvaryum balığıydı ve diğeri bir faunaydı). LCD' ler artık bu sorunu yaşamamaktadır ama ekran koruyucular hala dekoratif olarak bulunmaktadır.

LCDler akıllı telefon boyutundan duvar boyutuna kadar bütün boyutlarda bulunabilir, en önemli özelliği çözünürlükleridir, bilgisayarlar genelde 1366 x 768 (yatay x dikey) ile 1920 x 1080 arasında bir çzöünürlük sunarlar. (Daha düşük ve daha yüksek çözünürlükler mümkündür ama ekonomik ya da görsel olarak gerekli değillerdir.) Bilgisayarların büyük bir kısmı genişletilmiş çalışma ortamlarında birden fazla ekranı desteklerler.

Ayrıca bugün genel olarak yüksek çözünürlükü televizyona karşılık gelen 16:9 ölçüsü bulunur – bilgisayarların büyük bir kısmı televizyon izlemek için kullanılmadığı için aslında bu saçma bir gelişmedir. Daha uzun ama dar ekranlar (4:3 gibi formatlar) sık kullanılan programlar için daha uygun olurlar.
\paragraph{Diğer Bileşenler}{Bilgisayara bizim anlattığımız bileşenlerden daha fazlasını bağlamanız mümkündür. Yazıcılar, tarayıcılar, kameralar, televizyon alıcıları, modemler, robotik kollar, komşularınızı rahatsız edecek küçük füze atıcılar ve bunun gibi şeyler. Bu listenin gerçekten bir sonu yok ve bütün değişik cihazları burada anlatamayız. Yine de bu birkaç gözlem yapamayacağımız anlamına gelmez.}
\begin{itemize}
 \item Bir tane güzel yeniliklerden biri, örnek olarak, bağlantıların basitleştirilmesidir. Neredeyse bütün değişik sınıftaki cihazlar kendi arayüzlerini kullanıyorken (yazıcılar için paralel arayüzler, modemler için seri arayüzler, klavye ve fareler için PS/2 arayüzü, tarayıcılar için SCSI, …) bugünlerde çoğu cihaz USB' yi (universal serial bus) kullanıyor. USB kısmen güvenilir ve kabul edilebilir bir hıza sahip olmakla birlikte bilgisayar çalışırken tak-kullan özelliğini destekler.
 \item Bir diğer yenilik bileşenlerin kendi içlerinde daha akıllı olması ile ilgili. Önceden pahalı yazıcılar bile elektrikli daktiloların kabul edilebilir derecede IQ derecesine sahip olan aptal cihazlardı ve programcıların istenen doğru çıktıyı alabilmek için yazıcıya tam olarak doğru kodu oldukça dikkatli bir şekilde göndermesi gerekiyordu. Bugün yazıcılar (en azından iyi yazıcılar) programcılar için daha az sorun yaratacak şekilde kendi destekledikleri özgün programlama dillerine sahipler ve kendi içlerinde bir bilgisayar sayılabilirler. Bu durum çoğu diğer bileşen için aynıdır.
\end{itemize}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Bilgisayarınızın içini açın (tercihen bir öğretmen ya da yasal koruyucunuz gözetiminde, ve önce elektrik bağlantılarını kapatmayı unutmayın!) ve işlemci, bellek, anakart, ekran kartı, güç kaynağı ve hard disk gibi önemli parçaları bulmaya çalışın. Bilgisayarınızın hangi parçalarından burada bahsedilmedi?
\end{itemize}}
\end{section}

\begin{section}{Yazılım}

Bilgisayarın donanımı, içerdiği teknik parçalar, önemli olduğu gibi yazılımı da
\footnote{Donanımın tanımı: “Bilgisayarın vurulabilen parçalarına denir.” (Jeff Pesis)}, çalıştırılabilir programlar, oldukça önemlidir. Bu yaklaşık olarak üç kategoriye bölünebilir.

Firmware bilgisayarın anakartında depolanır ve eğer uygun değilse değiştirilip yerine başka bir firmware kullanılabilir. Bu bilgisayarı açtıktan sonra bilgisayarı tanımlı olan bir duruma getirmek için kullanılır. Genelde saati ayarlamaya yarayan ya da anakarttaki bazı özellikleri açıp kapatmaya yarayan bir kurulum modunu uyandırmak için bir yol bulunur.

Kişisel bilgisayarlarda bu yazılım BIOS (Temel Girdi/Çıktı Sistemi) olarak adlandırılır, daha yeni sistemlerde bunun adı EFI olarak geçer.

Bazı anakartlar normal Linux' dan daha hızlı açılan küçük bir Linux sistemi yüklü olarak gelirler, bu sadece Windows' u açmaya gerek kalmadan internette gezinme ya da DVD izleme gibi sınırlı işlevler görür.

İşletim sistemleri bilgisayarı kullanılabilir bir cihaz yapar: İşletim sistemi bellek, sabit disk, ayrı çalışan programların işlemcide kullanabilecekleri zaman ve diğer bileşenlere erişim gibi bilgisayar kaynaklarının kullanımının nasıl olacağını yönetir. Programların başlamasına ve durmasına izin verir ve aynı bilgisayarda olan farklı kullanıcılar arasında bir ayırıcı görevi görür. Bunların dışında giriş seviyesinde bilgisayarın yerel bir ağa ya da internete katılmasını sağlar. İşletim sistemi görsel bir arayüz sunar ve bu kullanıcıların bilgisayarın nasıl çalıştığı ile ilgili bir fikir verir.

Yeni bir bilgisayar aldığınızda bu genellikle önceden kurulmuş bir işletim sistemi ile gelir: Kişisel bilgisayarlar Microsoft Windows, Mac bilgisayarlar OS X, akıllı telefonlar genelde Android (bir Linux türevi) kullanır. Bununla birlikte işletim sistemi donanıma firmware gibi bağlı değildir ve herhangi birisi bir yenisiyle değiştirilebilir. Örneğin çoğu kişisel bilgisayarlara ve Mac bilgisayarlara Linux kurabilirsiniz.

Ya da Linux'u var olan bir işletim sisteminin yanına ek olarak da kurabilirsiniz, bu bir sorun yaratmaz.

Kullanıcı-seviye programlar kullanışlı bir şeyler yapmanızı sağlarlar. Bu belge yazmak, resim çizmek ya da değiştirmek, müzik bestelemek, oyun oynamak, internette gezinmek ya da yeni bir yazılım geliştirmek olabilir. Bu programlar uygulamalar olarak adlandırılırlar. Bunlara ek olarak genelde işletim sisteminin size sağladığı bazı araçlar bulunur, bunlar bilgisayar ayarlarında değişiklik yapmanıza izin verirler. Sunucular genelde diğer bilgisayarlara web, posta ya da veritabanı gibi bazı hizmetler sağlarlar.
\end{section}


\begin{section}{En Önemli İşletim Sistemleri}
\begin{subsection}{Windows ve OS X}

İşletim sistemi denildiğinde çoğu insanın aklına Microsoft Windows geliyor otomatik olarak. Bu günümüzde bilgisayarlarının çoğunun Windows yüklü olarak satılmasından kaynaklanıyor. Bu kendi başına kötü bir şey sayılmaz, çünkü bilgisayar sahipleri ilk sistem yükleme işlemi için uğraşmak zorunda kalmazlar. Ama olaya başka bir açıdan bakarsak bu Linux gibi alternatif sistemlerin tanınmasında bir sorun yaratıyor.

Aslında bilgisayarı Windows yüklü olarak almak o kadarda zor değildir çünkü bilgisayarınızı Linux ile kullanmak isteyebilirsiniz ama bu durumda sıfırdan bir sistem inşa etmek durumunda kalırsınız. Teoride bakıldığında kullanılmamış bir Windows için bilgisayar üreticisinden paranızı geri alabilirsiniz ama hepimiz biliyoruz ki bugüne kadar parasını geri almayı başarabilen çok fazla kişi olmadı.

Günümüzde kullanılan Windows 1990'lı yılların standartlarına göre oldukça iyi bir işletim sistemi olan “Windows NT” nin  varisidir. (Windows 95 gibi önceki sürümler mevcut bulunan Microsoft işletim sistemi MS-DOS' un grafiksel bir eklentisiydi ve o günün şartlarına göre oldukça ilkel sayılırdı.) Nezaket Windows' u kritik bir şekilde takdir etmemize engel oluyor, ama Windows' un bir insanın işletim sisteminden beklediği her şeyi, grafik kullanıcı arayüzü ve çoğu cihazı destekleme özelliği gibi, ortalama olarak karşıladığını söyleyebiliriz.

Apple’ın Macintosh' u 1984' te piyasaya sürüldü ve o zamandan beri Mac OS olarak adlandırılan bir işletim sistemini kullanıyor. Yıllardan beri, Apple tabanda birçok değişiklik yaptı (günümüzün Mac' leri teknik olarak Windows bilgisayarlar ile aynı) ve bu değişikliklerin bazısı oldukça radikal oldu. 9 numaralı sürümüne kadar (9 da dahil olmak üzere ) Mac OS zayıf bir yapıydı, örneğin aynı anda çalışan birden fazla programa yetersiz derecede destek olabiliyordu. Günümüzdeki Mac OS X deki X bir Romen “10” rakamı (X karakteri değil) ve bu sistem temelde BSD Unix özelliklerini taşıyor.

Şubat 2012' den beri, Macintosh işletim sisteminin resmi ismi “Mac OS X” den “OS X” e değişti. Eğer “Mac OS” un gitmesine izin verirsek ne demek istediğimiz daha iyi anlaşılabilir.

Windows ve OS X arasındaki büyük fark, OS X' in Apple bilgisayarları ile özel olarak satılması ve “normal” bilgisayarlarda çalışmıyor olması. Bu durum Apple' a çok kararlı bir sistem oluşturmayı sağlıyor. Bunun dışında Windows neredeyse bütün bilgisayarlarda çalışıyor ve hiç görülmeyecek şekilllerde birleşebilecek çok geniş bir donanıma destek sunuyor. Bu yüzden Windows kullanıcıları bazen çözülmesi zor ya da bazen çözülmesi imkansız uyumsuzluk sorunları ile karşılaşabilirler.  Buna rağmen Windows tabanlı bilgisayarlarda çok geniş bir donanım seçme imkanı bulunur ve böylece fiyatlar daha uygun seviyeye iner.

Windows ve OS X' in benzer noktaları ikisininde patentli bir yazılım olması: Kullanıcılar Microsoft ya da Apple önlerine neyi koyarsa onu kabul etmek zorundalar ve değil sistemi değiştirmek sistemin kendisini inceleyemezler bile. Bir güncelleme sistemine bağlıdırlar ve eğer üretici bir şeyi siler ya da başka bir şey ile değiştirirse buna uyum sağlamak zorundadırlar.

Burada bir fark bulunur: Apple genel olarak bir donanım üreticisidir ve OS X' i sadece Mac bilgisayarları alanlara sağlar. (bu yüzden OS X Mac-olmayan bilgisayarlar için değildir.) Diğer elde Microsoft bilgisayarları inşa etmez, sadece bilgisayarlarda çalışacak Windows gibi yazılımları satarak para kazanır. Bununla birlikte, Linux gibi bir işletim sistemi Apple' dan çok Microsoft' a bir tehdit oluşturur çünkü Apple alan insanların çoğu Apple bilgisayarı (tüm paketi) istedikleri için alırlar sadece OS X ile ilgilendikleri için değil. Bilgisayar dünyası, tablet ve diğer yeni moda Windows çalıştırmayan bilgisayarların istilası altına girdi ve bu Microsoft' u büyük bir baskı altına sokuyor. Apple bu durumdan Mac' ler yerine iPhone ve iPad'leri satarak kolayca kurtulabilir ancak Windows olmadan Microsoft iflasın eşiğine gelebilir.
\footnote{Aslında gerçek savaş alanı Windows değil Office'dir – çoğu insan Windows' u hayranlıklarından değil ama eğlence için kullanılabilen (ucuz) bir işletim sistemi olduğu için kullanır ve bu bilgisayarlar Office'i çalıştırır-- fakat aynısı Apple ve Google'ı yer değiştirirsek de olur. Bir gerçek olarak, Office ve Windows Microsoft'un para kazanabildiği yegane ürünlerdir; bunun dışındaki Microsoft'un yaptığı her şey (muhtemelen Xbox oyun konsolu hariç) bir kayıptır.}
\end{subsection}
\begin{subsection}{Linux}

Linux ilk başta Linus Torvalds tarafından bir merak duygusu ile başladı fakat sonra kendi hayatını kurmaya başladı. Bu zamanlarda yüzlerce geliştirici (sadece öğrenci ve bu işle hobi için uğraşan insanlar değil ayrıca IBM, Red Hat ve Oracle gibi firmalardaki profesyoneller) tarafından geliştirildi.

Linux'ta 1970'lerde AT\&T nin Bell Laboratuvarında geliştirilen ve küçük (küçük tanımı için yukarıyı inceleyin) bilgisayarlar için tasarlanan bir işletim sistemi olan Unix' ten esinlenilmişti. Unix kısa sürede araştırma ve teknoloji alanında tercih edilen bir sistem olmuştu. Büyük bir bölümde Linux Unix' in tasarımını ve temel fikirlerini kullanmaktadır ve Unix yazılımını Linux üzerinde çalıştırmak oldukça kolaydır fakat Linux'un kendisi Unix kodlarını içermez ve bağımsız bir projedir. Windows ve OS X'in tersine Linux ekonomik olarak ayrı bir şirket tarafından desteklenmiyor. Linux özgürce alınabilir ve oyunu kuralına göre oynayan herkes tarafından kullanılabilir. (bir sonraki bölümde belirtildiği gibi) Bütün bunlarla birlikte Linux sadece kişisel bilgisayarlar üzerinde değil, telefonlardan (en popüler akıllı telefon işletim sistemi, Android, bir Linux türevidir) en büyük anaçatı bilgisayarlara (dünyanın en hızlı 10 bilgisayarının hepsi Linux üzerinde çalışır) kadar çoğu sistemde çalışır ve bu Linux' u modern bilgisayar tarihinde en esnek işletim sistemi yapar.

Linux tek başına bir işletim sistemi çekirdeğidir ,uygulamaların ve özelliklerin kaynak kullanımızı ayarlayan bir programdır. Uygulamaları olmadan gelen bir işletim sistemi çok kullanışlı olmadığından, insanlar genelde bir Linux dağıtımını yükler. Dağıtım kararlı bir Linux' a sahip belirli uygulama, özellik, belgeleme ve diğer kullanışlı özellikleri barındıran bir pakettir. Buradaki güzel olan şey, Linux' un kendisi gibi, çoğu Linux dağıtımı özgürce kullanılabilir bir durumdadır ve ücretsiz ya da çok düşük bir fiyatla kullanılabilirdir. Bu şekilde binlerce dolarlık Windows ve OS X lisansı almadan ve lisans kısıtlamalarına maruz kalmadan bütün bilgisayarlarınıza, Ayşe teyzenizin ve arkadaşlarınız Zeynep ve Emre' nin bilgisayarlarına rahatça Linux dağıtımlarından istediğinizi kurabilirsiniz.

Linux ve Linux dağıtımları ile ilgili daha fazla bilgiyi ikinci bölümde bulabilirsiniz.
\end{subsection}
\begin{subsection}{Farklılıklar ve Benzerlikler}

Aslında bu üç büyük işletim sistemi sadece kullanıcıya sundukları şeyler konusunda sadece detaylarda farklılık gösterirler. Bu üç sistemde kullanıcıya herkesin kullanabileceği şekilde dosyaları “sürükle ve bırak” şeklinde özelliklere sahip olan bir grafiksel kullanıcı arayüzü sunar. Çoğu popüler uygulamalar bu üç sistem içinde mevcuttur, bu yüzden zamanınızın çoğunu internet tarayıcısı, ofis uygulamaları ya da bir e-mail programında harcadığınız için aslında hangisini kullandığınızın bir önemi kalmaz. Bu bir avantajdır çünkü bu bir sistemden diğerine geçişi mümkün kular.

Grafiksel arayüz dışında, üç sistemde metin şeklinde girilen komutların sistem tarafından çalıştırılabileceği bir çeşit “komut satırı” sunar. Windows ve OS X' de bu özellik genelde sistem yöneticileri için kullanılabilir durumdadır, normal bir kullanıcının bunu kullanmaması gerektiği yönünde bir düşünce bulunur. Linux' ta komut satırı daha az saklanmış vaziyettedir, bu Unix'in bilimsel/teknolojik felsefesi nedeniyle olabilir. Aslında bir gerçek olarak, çoğu görev Linux' un(ve bir açıdan da OS X' in) sağladığı güçlü araçlarla birlikte komut satırından daha etkili bir şekilde çalıştırılabilir. Yeni bir Linux kullanıcısı olarak sizde komut satırını açıp, bunun güçlü ve zayıf yönlerini öğrenmelisiniz, grafiksel arayüzün güçlü ve zayıf yönlerini öğrenmeniz gerektiği gibi. İkisinin karışımı size oldukça büyük bir çok yönlülük kazandıracaktır.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Eğer Windows ve OS X gibi patentli bir işletim sistemi ile deneyiminiz olduysa: En sık hangi uygulamaları kullanıyorsunuz? Bunlardan hangileri özgür yazılım?
\end{itemize}}
\end{subsection}
\end{section}

\begin{section}{Özet}

Bugünün kişisel bilgisayarları, ister Linux tabanlı olsun ister Windows ya da OS X donanımları, temel konseptleri ve kullanım amaçları düşünüldüğünde farklılıktan çok benzerliklere sahipler. Hiç şüphe duymadan günlük işlerinizi yapmak için bu üç sistemden birini kullanabilirsiniz, hiçbiri açıkça ve itiraz edilemez bir şekilde "en iyi" değil. Bununla birlikte, bu kitap daha çok Linux hakkında, kalan sayfalar boyunca sistemin kullanımı ile ilgili olabilecek en fazla bilgiyi sağlamaya çalışacağız, sistemin gücüyle ilgili olan kısımları ortaya koyacağız ve zayıf olan yönlerinden bahsedeceğiz. Şimdilik Linux diğer iki sisteme karşı ciddi bir alternatif ve diğerlerinden değişik açılardan -özellikle bazı yönlerden- daha üstün. Sizin Linux ile ilgilendiğinizi görmekten mutluyuz ve umarız Linux'u öğrenirken, pratik yaparken ve kullanırken eğlenirsiniz. Eğer LPI'nin Linux Essentials sertifikası ile ilgileniyorsanız sınavda başarılar dileriz!
\paragraph{Özet}{
\begin{itemize}
\item Bilgisayarlar verileri otomatik olarak çalıştıran, koşullu çalışmaya ve döngülere izin veren, değiştirilebilir programları barındıran cihazlardır.
\item Bilgisayarın en önemli parçaları işlemci, bellek, ekran kartı, anakart, sabit disk ve buna benzer parçalardır. 
\item Bilgisayarda bulunan yazılımlar firmware, işletim sistemi ve kullanıcı seviyesi programlar olarak üç gruba ayrılabilir. 
\item En popüler işletim sistemi Microsoft Windows' tur. Apple bilgisayarları OS X olarak adlandırılan başka bir işletim sistemi kullanır.
\item Linux bilgisayarlar için alternatif bir işletim sistemidir ve tek bir şirket tarafından değil çok sayıda gönüllü tarafından geliştirilir. 
\item Linux dağıtımları Linux işletim sistemi çekirdeğini uygulamalar ve belgelendirmeler ile kullanılabilir bir sisteme dönüştürür
\end{itemize}}
\end{section}


\chapter{Linux ve Özgür Yazılım}
\paragraph{Amaçlar}{
\begin{itemize}
 \item Knowing the basic principles of Linux and free software
 \item Being able to place the basic FOSS licenses
 \item Having heard of the most important free applications
 \item Having heard of the most important Linux distributions
 \end{itemize}}
 
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Basic knowledge about computers and operating systems
 \end{itemize}
\begin{section}{Linux: Bir Başarı Öyküsü}

1991 in yazında Linux Torvalds 21 yaşındayken Finlandiya’ da Helsinki Teknik Üniversitesinde bilgisayar bilimleri bölümünde okuyordu. Bu zamanlarda yeni bir 386 sı vardı ve işletim sistemi olmadan direk donanım üzerinde çalışan bir terminal emülatörü yazarak(bu ona üniversitesindeki Unix sistemine erişimini sağlamıştı) kendisini eğlendiriyordu.  Bu program zamanla ilk Linux işletim sistemi çekirdeğine dönüştü.

Bu zamanlarda Unix zaten 20 yaşındaydı ve üniversiteler ile araştırma kurumlarının seçtiği işletim sistemleri Unix'in birer çeşidiydiler.

Unix in kendisi de –aynen linux gibi- Kend Thompson ile Dennis Ritchie nin Bell Laboratuvarlarındaki (AT\&T nin araştırma kurumu) hobi amaçlı projelerinden biri sonucunda oluşmaya başladı. Çok kısa zamanda çok kullanışlı bir sisteme dönüştü ve büyük bir parçası yüksek seviye bir dille yazıldığı için (C) oldukça kısa bir zamanda üzerinde yazıldığı PDP-11 den başka bilgisayarlara da taşınabiliyordu. Ek olarak 1970lerde .... ve sistem çok küçük olduğundan dolayı ve bir derece basit olduğundan üniversitelerin çoğunda ders olarak işlenmeye başladı.

1970lerin sonlarına doğru Berkeley deki California Üniversitesi Unix i VAX a port etti, PDP-11 in halefi, değişikliklerin yapıldığı bu sistem BSD olarak duyuruldu. BSD türevleri hala bulunmaktadır.

Linux’ un ilk versiyonunu geliştirmek için Linus Minix’ ten yararlandı. Minix Amsterdam Özgür Üniversitesindeki Andrew S. Tanenbaum tarafından öğretim amaçlı yazılmış bir sistemdir. Minix küçük tutulmuştu ve özgürce ulaşılabilir değil bu yüzden ciddi bir işletim sistemi olarak tanınmamıştır.

25 Ağustus 1991’ de Linux projesini herkese duyurdu ve dünyanın kalanını katılması için davet etti.Bu noktada sistem Minix için alternetif bir işletim sistemi çekirdeği olarak görev yaptı.

O zamanlarda sistem bir isme sahip değildi. Linux “Freax” diyordu (Freak ve Unix in karışımı olan bir kelime), ayrıca ilk başta Linux olarak tanıtmıştı ama sonra bunun çok egoistçe olduğunu düşündü. Linus’un sistemi üniversitenin ftp sistemine yüklendiğinde, Freax ismini beğenmeyen Linus’ un okuldan arkadaşı Ari Lemmke ismi Linux’ a değiştirdi. Linus sonradan bu değişikliği onayladı.

Linux dikkate değer bir ilgi ve yardım edecek çok fazla gönüllü buldu. Linux 0.99 Aralık 1992 de GPL in ilk versiyon lisansı altında lisanslandı ve Unix işlevselliğine sahip kullanılabilir bir işletim sistemi olmuş oldu.

Linux 2.0 1996 nın başlarında ortaya çıktı ve çoklu işlemci desteği ve çalışırken çekirdek modüllerini yükleme gibi bir çok önemli yenilikle birlikte geldi. Bir diğer önemli değişiklik penguen “Tux” oldu, Linux’ un maskotu.  Linus Torvalds Avustralya’ da bir penguenle karşılaşmış ve bundan çok etkilenmişti. Sarı ayakları ve gagasıyla oturan simgesel penguen Larry Ewing tarafından çizilmiş ve camiaya sunulmuştur.

Linux 2.6 gelişim sürecinde yeni bir yapılaşma sürecine girdi. Önceki sürümlerde son kullanıcıya uygun sürümlerle geliştirici sürümleri ayrı olarak sunuluyordu. Linux 2.6 dan itibaren geliştirici çekirdekleriyle normal olanlar arasındaki çizgi kalktı ama gelecek sürümdeki geliştirmeler önceden sunulup resmi bir sürüm sunulmadan ayrıntılı bir şekilde test edildi.

Bu ortalama olarak şu şekilde oluyor: Linux 2.6.37 yayınlandıktan sonra, Linus sonraki çekirdek için önerilen değişiklik ve gelişmeleri topladı ve kendi resmi sürümü olan Linux 2.6.38-rc1 sürümünü çıkardı. Bu sürüm çeşitli insanlar tarafından test edildi ve bütün değişimler ve geliştirmeler 2.6.38-rc2 sürümünde toplandı. Sonunda kod resmi olarak yayınlanacak şekilde stabil bir hale geldi ve Linux 2.6.38 olarak yayınlandı ve bu işlem 2.6.39 ile devam etti.

Linus’ un resmi sürümlerine ek olarak başka geliştiriciler tarafından geliştirilen Linux sürümleri bulunmaktadır. Örnek olarak there is the “staging tree” where new device drivers can “mature” until (after several rounds of improvements) they are considered good enough to be submitted to Linus for inclusion into his version. Once released, many Linux kernels receive fixes for a
certain period of time, so there can be versions like 2.6.38.1, 2.6.38.2, ….
Temmuz 2011’ de Linus 2.6.40 olarak hazırlanan sürümü Linux 3.0 olarak duyurdu. Bu çok büyük değişiklikler olmamasına rağmen numaralama işlemini basitleştirmek için yapılmış bir değişimdi.

Bugünlerde kullanıcı için yapılan çekirdek sürümleri 3.2-rc1 olarak adlandırılmaktadır bu yüzden düzenlemelerle gelen sürümler 3.1.1, 3.1.2,… olarak adladırılırlar. "Linux" projesi bugün hiçbir şekilde bitmiş değildir. Linux dünya çapında programcılar tarafından sürekli geliştirilmekte ve bu  durumdan memnun olan milyonlarca özel ve ticari kullanıcıya hizmet vermektedir. Bilgisayar endüstrisi içersinde  Linux çekirdeği üzerinde  önemli pozisyonlarda çalışan birçok kişi var ve bazıları çevresindeki en saygın profesyonel geliştiricilerdir.

linux işletim sistemi doğası gereği çok yönlü donanım desteğine sahiptir, kesin bir kanıya varmamakla birlikte bütün platformlarda çalıştığı iddia edilebilir(akıllı telefonlar ve büyük sistemler de dahil olmak üzere) ve aynı zamanda Intel PC platformlarının örnek oluşturduğu donanım sürücüleriylede uyumludur. Linux sanayi ve akademi alanında  yeni bir işletim sistemi geliştirmek için araştırmalara konu olan  mevcut işletim sistemleri içersinde şüphesiz en yenilikçi olanıdır.

Çok yönlü olması Linux'u sanallaştırma ve "Bulut bilişim" gibi uygulamalar için tercih edilen işletim sistemi yapar. Sanallaştırma kendi işletim sisteminiz üzerinde çalıştırdığınız programlar yardımıyla tek bir gerçek ("fiziksel") bilgisayarda  pek çok "sanal" makina kurup  gerçek bilgisayarlar gibi kullanmayı mümkün kılar. Bu işlem kaynakları daha verimli kullanmamızı sağlar ve daha fazla esneklik imkanı vardır: Ortak sanallaştırma altyapıları ile sanal makineleri bir fiziksel makineden diğerine hızlıca taşımak mümkündür ve bu yapılar yükleme hataları ve arıza gibi durumları yönetmek için çok elverişlidir.

Bulut bilişim fikri büyük bilgisayar firmalarının sadece ihtiyaç anında ve kısa süreli lazım olan verileri depolamak için alternatif aramalarıyla oluştu çünkü bu çok maliyetli bir işti. Bulut bilişim kullanıcılarına sağlayıcılar üzerindeki sanal makinalara erişim izni verilir, alanlara kullanıma bağlı olarak yükleme yapılabilir ve bu sistem,işlemi gerçek bir sistemde sürdürmekten çok daha tasarrufludur böylece 7/24 calışacak bir bilgi işlem merkezinin kurulması için gerekli olan inşaat giderleri,personel giderleri,malzeme ve enerji giderleri gibi masraflardan kaçınılmış olunur.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item internetten Andrew S., Tanenbaum, Linus Torvalds ile ilgili olan meşhur tartışmayı bulun Tanenbaum Linus Torvalds'ın Linux'u üretirken başarısız oldugunu düşünüyordu. Sen ne düşünüyorsun ?
 \item Linux çekirdeğinin kaynağı olan en eski kurulum kodunun sürüm numarası nedir bulabilir misiniz?
\end{itemize}}
\end{section}
\begin{section}{Bedava yazılım mı açık kaynak kodu mu?}
\begin{subsection}{Telif Hakkı Ve Özgür Yazılım}
Ortaçağ boyunca kitap ve   diğer yazılı ürünlerin çoğaltılması çok pahalı bir işti. Gerekli sürede elde yazabilen birini bulmak gerekiyordu -- manastırlar incil kopyalamak için zamanın en iyi projelerinden birini yapmıştı(yazı yazmayı bilen rahipler vardı ve çok fazla boş zamanları vardı.) 16.yüzyılda matbaanın bulunması ile birlikte kopyalama işlemi daha basit ve ucuz oldu ve yayımcılık sektörü satmaya değer görülen her şeyi kopyalayıp dağıtmaya başladı. O zamanlarda yazarların neredeyse hiç hakkı yoktu, eğer yayımcılar onlara kendi çalışmalarını basmak için para öderse şanslıydılar. Gittikçe yayılan kopyalama orijinal yazıcıları kızdırdı, kendilerini aldatılmış hissettiler. Bu belirli çalışmalar için hükümetten özel haklar istemelerine neden oldu. Hükümet basılan yayınları denetlemek için bunu reddetmedi. Zamanla bu “özel haklar” yazarlara da geçti ve modern haliyle “telif hakkı” (ya da yazar hakları) olarak bilinen duruma dönüştü.

Telif hakkı bir işi yapan kişinin (bir kitabın yazarı, bir resmin ressamı, ...) o esere ne yapılacağı ile ilgili bütün haklara sahip olması demektir. Yazarlar kitaplarının basım haklarını yayıncılara verebilir ve kitaplarının piyasaya sürülmesini sağlayabilir; yazar basma, yayımlama, pazarlama ve buna benzer hiçbir şey ile uğraşmayarak yine de parasını kazanabilir, yayımcı ise kitap yazma derdinde olmadan para kazanabilir. Bu iki tarafında yararına olan bir durumdur.

Buna ek olarak “telif hakkı” “manevi hak” olarak belirlenebilir. Genelde bu hakları devretmek imkansızdır.

20.yüzyılda telif hakkı tasarımı uluslar arası olarak kabul gördü ve kayıt ve film endüstrisine de yansıdı. Bilgisayarın icadı ve internet durumu bir kere daha ciddi şekilde değiştirdi: Patentlerin amacı yayımcıyı diğer yayımcılara karşı korumaktı, aniden bilgisayara sahip olan herkes dijital içerikleri kopyalamaya başladı (yazılım, kitaplar, müzikler ve filmler gibi), bu yayımcılar, müzik, filme ve yazılım firmaları için bir felaketti, çünkü bu kurumların iş modeli olan bu ürünleri satmak tehlikeye girmişti. O zamandan beri “içerik endüstrisi” daha sıkı patent yasalarına ve korsan kopyacılar için daha yüksek cezaların konulması yönünde sıkı çalışmalara başladı ve aynı zamanda telif haklarını ihlal edenler hakkında soruşturma açmaya çalışıyor (ve bir açıdan başarılı oluyorlar).

Günümüzde "fikri mülkiyet" sadece telif haklarını değil aynı zamanda marka ve patent haklarınıda içerir. Teknik süreçlerin belgelenmesi  ve yayınlanmasından sonra patentler mucitlere buluşlarını kullanma ve yararlanma hakkı verir.(ör. buluşlarından yararlanma hakkını para karşılılığında başkalarına verebilirler). Ticari markaların popülerleğinin başkaları tarafından kullanılarak istismar edilmesi engellenir. Örneğin kimse  kahverengimsi ve şekerli bir içeceği “Coca-Cola” ismi ile satma hakkına sahip değildir. fikirler için üç ceşit "fikri mülkiyet"  vardır ve birbirini tamamlayıcı niteliktedir, telif hakkı somut ifadesi ile fikirlerin gerçek çalışmalar ile ilgili kısmını şekillendirir ve ticari markalara  kalitesiz iş uygulamalarını durdurma hakkı verir.

Seri üretim yapmak için telif hakkına sahip olunmalıdır ve bunun içinde çalışma küçük değişiklirler dışında son halini almış olmalıdır. Patentler patent ofisi tarafından yenilik açısından incelenerek verilir. Ticari markalar kesinlikle tescillenmiş olmalıdır fakat ürün veya hizmet sağlayıcısı kamu tarafından tanınana kadar  belirli bir süre için logo kullanabilir.

Bilgisayar yazılımlarıda(yazılı bir çalışma şeklinde de olabilir, belirli bir seviyeye gelmiş yaratıcı bir düşüncede olabilir) telif hakları ile koruma altındadır. Bu telif hakkı sahibinin(programcı veya işveren) açık izni olmadan bir yazılımın bir bölümünü veya tamamını kopyalamanın yasadışı olduğu anlamına gelir.

Gecmişte bilgisayar yazılımı satışı çok yaygın değildi. Ya almış olduğunuz bilgisayar ile birlikte gelirdi(bu durumda fiyat epey yüksek olur,milyon dolarlar seviyesinde) yada kendiniz yazmak zorundaydınız . 1960'larda ve 1970'lerde universiteler programları ya değiş tokuş ederdi yada kopya programlar kullanırdı, 1976 yılında Bill Gates'in   MITS Altair 8800 için dehşetle yapmaya çalıştığı BASIC yorumlayıcı gerçekten çok popüler oldu ve bununla çok övgü aldı ama kimse fiyatını sormayı akıl etmedi ! Yazılım için para ödenmesi fikri kullanıcılar için tabiki mantıklı degildi hatta bazıları alay etti.

1970'li ve 1980'li yıllarda ofislerde bilgisayar kullanımı yaygınlaştı ve yazılım ihtiyacının artmasıyla birlikte yazılım satışı fikride yaygınlaştı. Bununla kalmayarak yazılım firmaları nasıl çalıştığı anlaşılmayan, düzenlemenin yada incelemenin münkün olmadığı kapalı kaynak kodlu yazılımlar sattılar. Bir gün MIT'de araştırma görevlisi olan Richard M. Stallman 1960 ve 1970'lerin şartlarındaki bu durumun tam tersine paylaşım kültürünün öne çıkacağı bir sistem üzerinde çalışmaya karar verdi . “GNU” projesi tamamlanamadı ama bazı bileşenleri günümüzde bile linux sistemlerinde kullanılmaktadır.

Richard M. Stallman(kısaca "RMS" olarak da bilinir) Özgür yazılım" fikrinin babasıdır. Bu bağlamda "Özgür" kelimesi "Sınırsız özgür" anlamına gelmez istenilen herşeyi yapmak mümkün olmayabilir yada özel yazılımlar için izin verilirmiştir. RMS yazılım paketini "Özgür" olarak adlandırmak için 4 şart arar  "Dört Özgürlük" ile tanışın:

\begin{itemize}
 \item Herhangi bir amaç için programı çalıştırmak  özgürlüğü (özgürlük 0).
 \item Programın nasıl çalıştığını inceleme ve istediğinizi yapacak şekilde değiştirme özgürlüğü(Özgürlük 1)
 \item Kopyaları dağıtma özgürlüğü böylece etrafınızdakilerde faydalanabilir (Özgürlük 2)
 \item Programı geliştirme ve geliştirilmiş versiyonu(modifiye edilmiş genel versiyon) açık olarak olarak yayınlama özgürlüğü, böylece bütün topluluk
faydalanır (Özgürlük 3).
 \end{itemize}

Programın kaynak koduna erişmek 1. ve 3. özgürlükler için bir ön koşuldur. Özgür yazılım fikri genel olarak olumlu karşılanır, öyle olmasına rağmen RMS ve Özgür Yazılım Vakfı (FSF) hedefleri genellikle yanlış anlaşılır. 1990'ların sonunda, Eric S. Raymond, Bruce Perens ve Tim O'Reilly Open Source Initiative(OSI)(açık kaynak girişimini) hazırlandı,bazılarına göre bu durum özgür yazılım için daha iyi ve daha az ideojik bir pazarlama yöntemidir. FSF bu fikirleri "sulandırılması" konusunda hevesli değildi,FSF ve OSI çok benzer hedeflere sahip olmasına rağmen aradaki anlaşmazlıklar bügün bile sona ermemiştir (Bazı anlaşmalar önemli insanların karmaşık egolarına bağlı olabiliyor).

“Özgür yazılım” tanımının içindeki “özgür” “masrafsız” olarak yanlış anlaşılmaya musaitken “açık kaynak kodlu yazılım ” tanımının içindeki “açık kaynak kodu” bu tür kaynak kodlarının değiştirilip değiştirilmediğinin denetlendiği yönünde yorumlanabilir-- Her ikisi de OSI temel ilkelerindendir. Bu anlamda, her iki terimde \% 100 kesindir. Topluluktan sıklıkla “FOSS” (for free and open-source software) olarak bahsedilir yada alternatif olarak “FLOSS” (free, libre, and open-source software, FLOSS where the libre is supposed to support the sense of “liberty”) kullanılır.

Herkes kopyalama ve değiştirme gibi haklara sahipse özgür yazılımdan nasıl para kazanılır ? bu çok doğal bir sorudur. Burada bir kaç örnek("açık kaynak için iş modelleri ") var:

\begin{itemize}
 \item Destek servisleri veya döküman sağlayabilirsiniz yada özgür yazılım eğitimi vererek para kazanabilirsiniz (Bu yaratıcı firmalar için çok iyi bir iştir, Linup Front GmbH ve LPI gibi şirketler Linux sertifikaları satarak geçimini sağlıyor).
 \item Belirli müşterileri için özel iyileştirmeler veya eklentiler oluşturup harcadıgınız zaman karşılığında para kazanabilirsiniz(yapmış oldugunuz geliştirmeler genel versiyonun bir parçası olur). Bunu eğer kendiniz için yapmıyorsanız bu çalışma özgür yazılım için başka bir alternatif olur.

Özel yazılım geliştirmenin "geleneksel" modeli çerçevesinde, yazılımın orijinal üreticisi değişiklik yapma ve geliştirme hakkını elinde bulundurur. Böyle bir şirketin müşterisi olarak, üretici ürünü üretimden kaldırırsa yada düpedüz kaybolursa diye kaygılanabilirsiniz (iflas edebilir ya da rakipleri tarafından satın alınabilir), çünkü bu büyük bir sorununuz var demektir ve geleceği olmayan bir yazılıma masraf yapmış olursunuz. Özgür yazılımda her zaman orjinal üreticilerden destek alacak birini bulursunuz--gerekirse diğer kullanıcılarla birlikte destek talep edebilirsiniz kimse yalnız kalmanızı istemez. Eğer bir paket yazılım satmak istiyorsanız önce FOSS seklinde bir temel sürüm hazırlayıp  insanları  daha gelişmiş özelliklere sahip “tam sürüm” satın almaya ikna edebilirseniz, bu işi başarırsınız (jargonda ifadesi "Açık çekirdek").

 \item Bu iki ucu keskin kılıç gidir: bir yandan bakıldığında aradıgız iş için çok sayıda bedava yazılım olması şüphesiz çok iyi bir şey olurdu fakat diğer taraftan bakıldığında genellikle ücretsiz versiyonlardaki önemli fonksiyonların kısıtlandığını görürsünüz ve işlevselleştirmek için çok fazla çalışmak gereklidir. Bu durumda ücretsiz(özgür) kelimesi bir çok sunucuda arama motorlarındaki popülerliği artırmak içim kullanılır ve bu durum yayıncıların "özgür yazılım dostu" olarak görünmek istemesiylede ilgilidir --yürümeden ilerleme kaydetmeye çalışmaktır.
 \end{itemize}
\end{subsection}
\begin{subsection}{Lisanslar}

Bir yazılım nasıl  "ücretsiz" veya "açık kaynak kodlu" hale gelir?  Bahsettiğimiz bazı haklar--örneğin kopyalama ve değiştirme hakkı-- kesinlikle çalışmanın sahibine aittir fakat bu kişi hakklarını başkalarına devredebilir. Bu yapmanın  yollarından biri lisanslamaktır, yasal bir belge ile yazılımın bazı haklarının satın alan kişide veya indiren kullanıcıda olduğu belirtilebilir. Telif hakları bir yazılımı satın alan kullanıcı(yada yasal olarak indirme hakkına sahip başka biri) için sadece kurma ve çalıştırma izni verir. Buradan yazılımın kullanılmasının yapımcının iznine bağlı olduğu gerçeği çıkarılabilir--Buradan satın almayan kullanıcıların kullanmasına izin verilmediği açıkça bellidir .(tam tersine.yapımcıya para verirse parasıyla yazılımın haklarını takas etmiş olur) . yazılımı kontrolsüz bir şekilde  kopyalama,dağıtma,bir kısmını veya tamamını değiştirmenin yasak olduğu telif haklarında açıkça belirtilmiştir hak sahibi izin vermek istiyorsa bunu lisans içersinde belirtmelidir.

Fikri mülkiyet hakkına tabi programlar genellikle "son kullanıcı lisans sözleşmesi (EULA)" ile birlikte gelir alıcı yazılımı kullanmak için  sözleşmeyi kabul etmek zorundadır. Yazılım satıcılarının EULA ile  alıcıları yasaklaması aslında telif hakları ile izin verilen bir şeydir ---
yazılımı başkasına  satarak kullanmasına izin vermek gibi, veya açık bir bir şekilde yazılımla ilgili kötü(aslında herhangi birşey) şeyler söylemek gibi.
EULA  sözleşmesinde oldukça fazla sayıdaki yasal engellemenin her iki tarafça da kabul edilmesi gerekiyor (en azından Almanya'da öyle). Örneğin, alıcı yazılımı almadan önce sözleşme şartlarını incelemek zorundadır ama sözleşme şartlarını kabul etmezse en azından parasının bir kısmı geri ödenmelidir.

Diğer taraftan, açık kaynak lisansı olan FLOSS için yazılımda yapılacak değişikleri telif hakkıyla yasaklamaktan başka yollar vardır. Genellikle yazılım kullanımını kısıtlamayı kimse istemez ama dağıtma ve değiştirme sürecini yönetirler. Bu şekilde alıcıyı en kötü durumda bile yanlız bırakmayarak onlardan daha iyi bir yazılım satın almalarını beklemezler. Bu nedenle, EULA'ların aksine, özgür yazılım lisansları genellikle sözleşme değildir alıcısı zorunluluk olduğunu açıkça kabul eder, yazılım yapımcıları adına tek taraflı beyanları ve onlar tarafından tanınan hakların dışında ekstra faydalardan oluşmaktadır, yasa aslında basit bir kullanım hakkıdır.

Artık temel kuralların yerine getirilmesi gereken hayvanat bahçelerinin yerinine ücretsiz yazılımlar ve  açık kaynak kodlu yazılımlar bulunmaktadır. En iyi bilinen özgür yazılım lisansı Genel Kamu Lisansı(GPL)  Richard M. Stallman ve diğerler tarafından yürürlüğe kondu. OSI kendi görüşüne göre açık kaynak ruhunu somutlaştıran bu lisansları "onaylar", FSF  lisansları onaylar ve "dört özgürlük" ile korur. Onaylı lisanslar listesi bu kuruluşların internet sayfalarında mevcuttur.

Eğer bir ücretsiz veya açık kaynak yazılım projesine başlamayı düşünüyorsanız, kesinlikle sizin için  gereklerini yerine getiren ücretsiz bir FSF yada OSI lisansı vardır. Bu lisansınız için FSF veya OSI'den onay almak gerekmediği anlamına gelirve bununla birlikte, zaten onaylanmış mevcut bir lisans kullanmak genellikle daha iyidir, mevcut lisanslar genellikle yasa uzmanları tarafından incelenmiş makul ve kabul edilebilir olduğu su geçirmezdir--
yeni bir amatör sözleşme veya fikri mülkiyet hukuku hazırlarken daha sonra başınızı derde sokabilecek önemli ayrıntılar göz ardı olabilir.

Önemli bir gözlem olarakta ücretsiz veya açık kaynak yazılım savunucuları hiçbir şekilde  yazılım için telif hakkını tamamen ortadan kaldırmak niyetinde değildir. Aslında, özgür yazılımcılar olarak biz telif hakklarının yazılımın değiştirme ve dağıtma gibi haklarını yasal olarak yapımcısına verdiğini biliyoruz ve bazı koşullar sağlanarak kullanıcılarında bu tür haklara sahip olması gerektiğini düşünüyoruz. Telif hakkı olmasaydı, herhangi bir yazılım için herkez birbirine yardım edebilirdi ve "dört özgürlük" gibi merkez ilkeler olmadan bu tehlikeli olabilirdi çünkü insanlar hiç bir paylaşımda bulunmadan birikimlerini saklayabilirdi.
\end{subsection}
\begin{subsection}{GPL}

Linux çekirdeği ve diğer bütün "Linux" paketleri Genel Kamu Lisansı (GPL) altında dağıtılmaktadır. GPL, RMS tarafından GNU projesi için geliştirilmiştir başlamakta olduğu yazılım için GPL lisansı ile dağıtılan yazılımın GPL altında kalması gerekiyordu(bu lisans tip copyleft lisans olarak adlandırılır). Bu yaklaşık olarak aşağıdaki gibi çalışır:

\begin{itemize}
 \item GPL Yazılımın kaynak biçiminde mevcut olması gerekir ve isteğe bağlı bir şekilde kullanılabilir olmasını amaçlar.
 \item Kaynağını değiştirmek için açıkça izin verilir kaynağı degiştirerek yada değiştirmeden dağıtabilirsiniz ve GPL bir sonraki alıcıyada aynı hakları verir.
 \item Ayrıca  GPL yazılımları çalıştıralabilir  formlarda bile dağıtmak münkün(hatta satabilirsiniz). Bu durumda, kaynak kodu (GPL hakları ile birlikte) yazılımın çalıştırılabilir formu ile birlikte sunulmalıdır yada istendiği takdirde belirli bir süreliğine paylaşılabilir.

Bu bağlamda "Kaynak kodu" almak demek yazılımı bilgisayarda çalıştırmak için gereken her şeyi almak demektir. Özel durumlar ne demektir-- örneğin kapalı bir bilgisayardaki değiştirilmiş Linux çekirdeğini uygun bir şekilde başlatmak için şifreleme anahtarları gerekebilir--bu hararetli bir tartışma konusudur.

Eğer biri para ile GPL yazılım satın alırsa, doğal olarak sadece bütün bilgisayarlarında çalıştırma hakkına sahiptir, kopyalayamaz ve yeniden satamaz.(GPL lisansı altında).Bunun bir sonucu olarak da "koltuk başına" GPL yazılım satmak  mantıklı bir iş değildir, bu durumun önemli bir sonucu olarakta fiyatlar açısından rahatlık sağlamasıdır bu sebeple Linux dağıtımları kullanmak mantıklıdır.

 \item Eğer bir GPL programına ait parçaları bir araya getirerek yeni program (bir "türetilmiş çalışma") yazarsanız, bu program GPL ile lisanslanmalıdır.
\end{itemize}

Burada da, hararetli tartışmalara sebep olan şey "türetilmiş program" yazmak için ne kadar GPL programı kullandığınızdır. FSF'ye göre,Bir program dahilinde dinamik olarak kullanarak GPL kütüphanesi kullanılıyorsa o program GPL altındadır, herhangi bir GPL kod  bu nedenle GPL altında olmalıdır hukuki anlamda bir "türetilmiş çalışma" olarak kabul edilemez. Bu durumlardan ne kadarının uydurma ne kadarının hukuken savunulabilir olduğu, prensip olarak, bir hukuk mahkemesinde tespit edilmelidir.

GPL, yazılımı kullanım için değil değiştirmek ve dağıtmak için kurallar belirlemektedir.

Şu anda  yaygın olarak kullanılan  iki GPL sürümü vardır.Yeni sürüm 3 (ayrıca "GPLv3" denir)  2007 Haziran ayında yayımlanmıştır ve eski sürümden (sürüm 2 (ayrıca "GPLv2") ) farkları yazılım patentleri gibi alanlarda açıklamalar, diğer ücretsiz lisansları ile uyumluluk, "özgür" yazılımların teorik olarak değişiklik yapmanın imkansız olduğu Özel donanımlarda çalıştırılması ile ilgili tanımlarıdır("Tivoisation",olan çekirdek, Linux tabanlı bir dijital PVR değiştirilemez ve yenilenemez). GPLv3 kullanıcılarınına başka şartlar eklemek için izin verir.--GPLv3 toplum içinde evrensel onayı almadı,dolayısıyla birçok proje (en belirgin, Linux çekirdeği) daha basit  olan GPLv2'de kalmıştır.Buna ek olarak, birçok proje "GPLv2 veya sonraki bir sürümünü" altında kodunu dağıtmaktadır, dolayısıyla bu tür yazılımları dağıtırken veya değiştirirken hangi sürümünün kullanılacağına GPL'i takip ederek kendiniz karar verebilirsiniz.

Projeye katılmak için  lisans kapsamında projenizle aynı bir projenin lisansını kullanmak özgür yazılım geliştiricileri arasında en iyi tarzı olarak kabul edilir, anonim kod  kullanmakta ısrar eden  bir çok proje için bu  "resmi" bir yoldur. Bazı projelerde projeye kod veren yapımcılar ısrarla telif hakkı atamaları(yada benzeri bir organizasyon) isterler. Bu adımın avantajı ise kodun telif hakkının ve telif hakkı ihlalinin projeye ait olmasıdır—telif hakkı sahipleri yasal dayanaklarına başvurabilir—muhattabını bulmak daha kolaydır. Beklenmeyen bişey olduğunda ya da olmasını istemediğiniz bişey olduğunda projenin lisansını degiştirmek kolaylaşır,böyle bişey olduğunda bunu yapma yetkisi sadece telif hakkı sahibindedir.

Linux çekirdeği proje durumunda olduğundan, açıkça telif ataması gerektirmez, kodlar binden fazla yazarın katkılarıyla oluşan bir toplu çalışma  olduğundan lisans değişikliği çok zor ya da imkansızdır. Bu sorun GPLv3 tanıtımı sırasında tartışıldı.Geliştiriciler yasal kaynakların sıralanması için dev bir proje yapılmasını kabul etti ve yazarlardan Linux çekirdek kaynak kodunun her satırı için lisans değişikliği onayı alındı. Inatla karşı çıkan Bazı Linux geliştiricileri oldu, orada bulunayaman yada vefat etmiş olan geliştiricilerde vardı onların kodlarının telif haklarını temizlemek için kodların yenilenmesi veya benzeri ile değiştirilmesi gerekiyordu. Bununla birlikte, en azından Linus Torvalds GPLv2  destekçisi olarak kaldı, bu nedenle uygulamada bir problem olmadı.

GPL ürünün olası fiyatı konusunda bir şart bulundurmaz. GPL yazılım kopyalarını vermek veya para karşılığında satmak kaynak kodlarını beraberinde vermek yada istendiğinde vermek şartıyla tamamen yasaldır ve alıcıda GPL haklarını alır.Bu GPL yazılımın ücretsiz olması gerekmediği anlamına gelir. GPL [GPL91] inceleyerek daha fazla bilgi bulabilirsiniz,dağıtılmış olan bazı  GPL-ed ürünleri (Linux içeriğinde var) inceleyebilirsiniz. GPL  bu anlamda ücretsiz lisansların en tutarlı olanı olarak kabul edilir-dediğimiz gibi-GPL tarafından sağlanan,altında yayımlanan, kod  özgür kalmalıdır. Şirketler çeşitli vesilelerle kendi projelerine GPL kod dahil etmeye çalışıyorlar, bu GPL den kurtulmak için bir bahana degildir. telif hakkı sahibi olarak (en sık) FSF'nin sert eleştirilerinden sonra bu şirketler GPL ile uyumlu hale gelmiştir.En azından, Almanya'da GPL mahkeme kararıyla doğrulanmıştır--Linux kernel programcısı D-Link (ağ bileşenleri üreticisi, bu durumda bir Linux tabanlı NAS cihazı)'e karşı Frankfurt bölge mahkemesinde elde edebilir karar çıkarmıştır,cihazı dağıtırken GPL uyulamadığını iddia ederek dava açmıştı.

Neden GPL çalışır? Bazı şirketler GPL'e ağır kısıtlamalar getirmeye ya da geçirsiz kılmaya çalıştı. Örneğin, Amerika Birleşik Devletleri'nde, "Amerikan karşıtı" ya da "anayasaya aykırı" olarak adlandırıldı ve Almanya'da bir şirket geçersiz kılmak için rekabet hukuku kullanmaya çalıştı GPL sözde yasadışı fiyat belirleme yapıyormuş. Eğer bir şeyler yanlış ise hiç kimsenin bunu yapmayacağı fikti GPL ile kanıtlanabilir gibi görünüyor. Aslında bu saldırılın önemli bir kısmı göz ardı edilebilir: GPL olmasaydı, yazılımda yapımcısı dışından herhangi birinin değişiklik yapması doğru olmazdı, böyle dağıtımlar yapılamazdı ve yazılım satışlarıda telif hakları yasası ile sınırlandırılırdı. Yani eğer GPL yok olursa, kodlarla ilgili eğlendiğiniz ne varsa öncekinden daha kötü bir hal alır.

Bu noktada davalı "hayır" da diyebilir ama eğer "evet" dersede karar değişmez kodun herhangi bir telif hakkının olmaması onları gene haklı çıkarır. Bu rahatsız edici bir ikilemdir çünkü gerçekten bazı şirketler bu durumu kendi çıkarları için kullanmıştır-GPL anlaşmazlıkları çoğunlukla mahkeme dışında yaşanır.

Eğer bir yazılım üreticisi GPL ihlali yaparsa (örn. kendi projesine yüzlerce satır GPL kodu eklerse ), bu o projenin bütün kodlarının artık GPL'den bağımsız olduğu anlamına gelmez. Yanlızca GPL kodunun lisanssız dağıtıldığı anlamına gelir, üreticiler  bu sorunu çeşitli şekillerde çözerler:
\begin{itemize}
 \item GPL kodunu kaldırarak kendi kodlarını koyarlar. Bu şekilde yazılımları GPL'den bağımsız olur.
 \item GPL kodunun  telif hakkı sahibi ile pazarlık yapabilirsiniz (eğer varsa ve pazarlık yapmak isterse) örneğin, bir lisans ücreti ödemeyi kabul edersiniz.
Ayrıca aşağıda birden çok lisans bölümüne bakınız.
 \item Onlar programın tümünü gönüllü olarak GPL altında  yayınlayabilir ve böylece GPL koşullarına(en olası yöntem) bağlı kalınmış olur.
 \end{itemize}

Bunlardandan bağımsız olarak, önceki ihlalleri için ödenecek zarar söz konusu olabilir. Sahipli yazılımın yazılım telif hakkı durumu  herhangi bir şekilde bundan etkilenmez.
\end{subsection}
\begin{subsection}{Diğer Lisanslar}

GPL'e ek olarak, FOSS gibi popüler diğer lisanslarda vardır. Işte kısa bir bakış:

\paragraph{BSD Lisansı}{BSD lisansı Berkeley'deki Kaliforniya Üniversitesinde başlatılmıştır Unix dağıtımları kasıtlı olarak çok basit tutulur: Yazılım alıcı universite(veya uzantısı, orijinal yazılım yazarı)  tarafından yapıldığı izlenimi oluşturmadan istediğini yapmakta özgürdür. Program için mümkün olduğunca herhangi bir yükümlülük bulundurulmaz. lisans metni programın kaynak kodu ve içinde--Değiştirilmiş versiyonlarda veya dağıtılan diğer çalıştırılabilir formlarda-- veya dökümanlarında korunmuş olmalıdır.}

Bir yazılım paketi BSD lisanslı kod içeriyorsa, bu kodun herhangi bir promosyon materyalinde yada bir sistemde kullanılması sorunu  telif hakkı sahibini ilgilendirir. Bu "reklam cümlesi" bir köşede dursun.

GPL'in aksine BSD lisansı yazılımın kaynağını açık tutmaya çalışmaz, isteyen  BSD lisanslı yazılımı aslında kendi yazılımının içine entegre edip binary olarak dağıtabilir(bu GPL yazılım olsaydı ilgili yazılımın kaynak kodunuda GPL altında dağıtmak gerekirdi).

Microsoft veya Apple gibi Ticari yazılım şirketleri, GPL yazılım konusunda daha az heveslidir fakat BSD lisanslı yazılımlar  ile hiçbir sorunları yoktur. Örneğin Windows NT tarafından kullanılan TCP/IP   network kodu(adapte şeklinde)  BSD'dir ve Macintosh'un OS X işletim sistemi BSD çekirdeğinin biraz daha geniş parçalarını kullanır.

FOSS toplulukları içinde,GPL veya BSD lisanslarından hangisinin "daha özgür" olduğu konusunda uzun süreler farklı görüşler belirtilmiştir. Bir taraftan bakıldığında mantıklı bir alıcı olarak , BSD lisanslı yazılımlarla daha özgürsünüzdür ve bu nedenle BSD lisansı mutlak olarak daha fazla özgürlük aktarıyordur. Öte yandan GPL savunucularına göre kodların ücretsiz kalması herkesin kullanması için önemlidir ve başka türlü olursa özel sistemler içinde kaybolunur , GPL kodunu almak isteyenlerin GPL yazılım havuzuna birşeyler vermek zorunda olması bu büyük özgürlüğün göstergesidir.

\paragraph{Apache Lisansı}{Apache lisansı BSD lisansı gibidir, yazılımların değiştirilmiş sürümlerinin aynı lisansı kullanarak ya da özgür-açık kaynak kodlu yazılım olacak şekilde dağıtılması koşulunu barındırmamaktadır. BSD' den daha karmaşıktır ama ayrıca patentleri, ticari marka haklarını ve diğer detaylar ile ilgili kullanım koşulları içerir.}
\paragraph{Mozilla Kamu Lisansı}{Mozilla lisansı (Firefox ve diğer yazılım paketlerine uygulanır) BSD lisansı ile GPL' in bir karışımıdır. Copyleft yanı zayıf kalan bir lisanstır, MPL lisansı altında alınan kodun MPL altında yayınlanması şart koşulurken (GPL gibi) eklenen kodlar MPL altında yayınlanmak zorunda değildir.}
\paragraph{Creative Commons}{Özgür Yazılım camiasının başarısı hukuk profesörü Lawrence (Larry) Lessig'i cesaretlendirdi ve Lawrence yazılıma ek olarak diğer çalışmalar içinde aynı durum için başvuruda bulundu. Amaç kitaplar, resimler, müzikler ve filmler gibi kültürel havuzu oluşan eserlerin herkesin kullanımına, değiştirmesine ve dağıtmasına özgürce açık olmasıydı. Yaygın özgür yazılım lisansları sadece yazılım üzerine oldukları için yaratıcı-üretimler lisansı eserlerini halkın kullanımına bağışlayan kişiler için geliştirildi. Bunlarda da bazı kısıtlamalar bulunabilir; sadece çalışmanın gösterilmesine izin verilebilir, GPL gibi değiştirilmiş ürünün ilerde yapılabilecek değişikliklere açık olarak sunulması istenebilir ya da yayının ticari amaçla kullanılması engellenebilir.}
\paragraph{Kamu Malı}{“Kamu malı” artık telif hakları altında olmayan kültürel eserler için uygulanır. Anglo-Saxon yasal kurallarına göre bir eserin yaratıcısı eserini (örneğin bir yazılım parçası) kendi bütün haklarından vazgeçerek kamu malı haline getirebilir ama bu her zaman bütün yasal çevrelerde geçerli olmaz. Örneğin Almanya' da eserler bu eser üzerinde en son çalışan kişinin ölümünden 70 yol sonra kamu malı haline geçer. İlk bilgisayar programının bu şekilde herkese açık duruma geçmesi için biraz daha beklememiz gerekiyor.}

1930' dan sonra üretilen telif haksız ürünlerin kamu malı durumuna geçmesi için bir ihtimal söz konusudur. Birleşik Devletlerde, Parlemento telif hakkı terimini süresi geçmiş bir çizgi film üzerinde genişletti ve dünyanın geri kalanı bunu izlemekten genel olarak memnun. Neden Walt-Disney' in torunlarının torununun gerçek bir artistin yaratıcılığından para kazanabileceği pek açık değil ama bu genelde en iyi lobiyi yapanlar tarafından belirlenen bir durum elbette.

\paragraph{Çoklu Lisanslama}{Temel olarak bir yazılım paketinin telif hakkı sahibi bu paketi aynı anda başka lisanslar altında da sunabilir – örneğin özgür yazılım lisansı GPL geliştiriciler için, sahipli telif hakkı kaynak kodlarını açıkça sunmak istemeyen şirketler için. Elbette bu en çok diğer programcıların kendi programları ile kullanabilecekleri kütüphaneler için anlam ifade eder. Kim sahipli bir yazılım geliştirmek isterse GPL kısıtlamalarından paralı lisans alarak kurtulabilir.}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item GPL ile ilgili olan yargılardan hangileri doğru ya da yanlıştır?
 \begin{enumerate}
 \item GPL yazılımı satılamaz.
 \item GPL yazılımı şirketler tarafından değiştirilerek kendi ürünlerinde kullanılamaz.
 \item GPL yazılım paketinin sahibi bu programı başka bir lisans altında da dağıtabilir.
 \item GPL geçerli bir lisans değildir çünkü lisans ancak kişi sözü edilen yazılım paketini aldığında lisansı görür. Bir lisansın geçerli olabilmesi için kişinin bu lisansı görüp yazılımı kullanmadan önce kabul etmesi gerekir.
 \end{enumerate}
 \item FSF'nin “dört özgürlüğünü” Debian Özgür Yazılım Kılavuzu ile karşılaştırın. (Bölüm 2.4.4 e bakınız.) Hangi özgür yazılım tanımını daha çok beğendiniz ve neden onu daha çok beğendiniz?
\end{itemize}}
\end{subsection}
\end{section}
\begin{section}{Önemli Özgür Yazılımlar}
\begin{subsection}{Genel Bakış}

Linux güçlü ve şık bir işletim sistemidir ama en iyi işletim sistemi bile üzerinde çalışacak programlar olmadan bir işe yaramaz. Bu bölümde normal Linux bilgisayarlarda bulunabilecek en önemli özgür yazılımlardan bir kısmını tanıtacağız.

Eğer belirli bir program söylediği şeyleri yapmıyorsa onları dikkate değer bulmuyoruz. Alanımız sınırlı ve LPI' nin ve sınavında geçen yazılım paketlerini anlatmaya çalıştık (ne olur ne olmaz).
\end{subsection}
\begin{subsection}{Ofis ve Geliştirici Araçları}

Çoğu bilgisayar muhtemelen ofis uygulamaları için kullanılıyordur, çünkü bu uygulamalar mektup ve anılarınızı, seminer kağıtlarınızı ya da yüksek lisans tezinizi yazmanızı sağlar, tablolar kullanarak verinin gelişimini gösterir ve buna benzer görevlere sahiptir. Kullanıcılar ayrıca bilgisayardaki zamanlarının çoğunu internette ya da mail okur ya da yazarken harcarlar. Bununla ilgili birçok özgür yazılım olmasına şaşmamalı.

Bu bölümdeki programların çoğu sadece Linux için değil ve Windows, OS X ve Unix türevleri içinde bulunmaktadır. Bu kullanıcıların işletim sistemlerini Linux ile değiştirmeden Microsoft Office, Internet Explorer ve Outlook yerine Libre Office, Firefox ya da Thurderbird kullanarak işlerini halletmelerini sağlar. Eğer kartlarınızı doğru oynarsanız kullanıcılar farkı görmeyebilir bile.
\paragraph{OpenOffice.org}{Uzun yıllar boyunca özgür yazılım camiasının büyük ofis tarzı uygulamalar konusunda amiral gemisi konumundaydı. Yıllar önce “Star Office” olarak başlamıştı ve Sun tarafından satın alındıktan sonra özgür yazılım olarak dağıtılmaya başlanmıştı. (hafif inceltilmiş bir hali) OpenOffice.org bir insanın bir ofis programından bekleyeceği her şeye sahip; kelime işlemci, tablolar, sunum hazırlama, veritabanı,... - ve büyük rakibi Microsoft' un dosya formatlarıyla iş yapabilecek düzeyde.}
\paragraph{LibreOffice}{Sun Oracle tarafından alındıktan sonra OpenOffice.org un geleceği belirsizdi ve OpenOffice.org un ana geliştiricilerinden bazıları birleştiler ve kendi OpenOffice.org sürümlerini yayınladılar. İki pakette şu an geliştirilmeye devam ediliyor (Oracle OpenOffice.org u Apache Yazılım Vakfına bağışladı), fakat ne zaman ve ne şekilde bir “birleşme” olacağı belli değil.}

Şu an çoğu büyük Linux dağıtımı LibreOffice ile birlikte geliyor, çünkü LibreOffice daha hızlı bir şekilde geliştiriliyor ve daha önemlisi daha temiz bir sürüm.
\paragraph{Firefox}{Şu anda en popüler internet tarayıcısı ve Mozilla Vakfı tarafından dağıtılmaktadır. Firefox bir zamanların en tepede olan tarayıcısı Microsoft' un Internet Explorer' ından daha güvenli ve daha hızlı çalışmaktadır, daha çok iş yapar ve daha rahat bir kullanım sunar. Bunlara ek olarak kendi isteklerinize göre Firefox' u özelleştirmek için varolan eklentileri kullanabilirsiniz.}
\paragraph{Chromium}{Google tarayıcısı Chrome' un özgür yazılım türevi. Chrome son zamanlarda Firefox ile yarışmaya başladı – Chrome' da eklentileriyle birlikte oldukça güçlü ve güvenli bir tarayıcı. Özellikle Google' ın desteği ile son zamanlarda hız kazanmaya başladı.}
\paragraph{Thunderbird}{Mozilla Vakfı' nın dağıttığı bir e-posta programı. Altyapısının büyük bir kısmını Firefox tarayıcısıyla ortak kullanıyor ve Firefox gibi değişik amaçlar için kullanılabilecek çok sayıda eklenti sunuyor.}
\end{subsection}
\begin{subsection}{Görseller ve Çoklu Ortam Araçları}

Görseller ve çoklu ortam Macintosh' un baskınlığı altında. (Windows tarafında da iyi yazılımlar sunulsa bile) Kabul etmek gerekirse, Linux hala Adobe Photoshop'a eşdeğer bir programın eksikliğini hissediyor fakat bu konudaki yazılımlarda o kadar da kötü değil.

\paragraph{Gimp}{resimleri düzenlemek için bir programdır. Photoshop'un eşdeğeri sayılmaz (örneğin bazı baskı öncesi özellikleri eksik) ama kesinlikle çoğu amaç için kullanılabilir hatta Photoshop' un iyi bir şekilde yapmadığı web için gereken grafikleri hazırlamak için birkaç araç sunuyor.}
\paragraph{Inkscape}{Gimp Linux'un Photoshop'u konumundayken Inkscape resimler için kullanılır, vektör tabanlı grafiklerin oluşturulması açısından güçlü bir araçtır.}
\paragraph{ImageMagick}{neredeyse bütün görsel formattaki dosyaları birbirine çevirmeye yarayan bir yazılım paketidir. Ayrıca resimleri betik kontrollü bir şekilde düzenleme yolları sunar. Web sunucuları ve grafiklerin bir fare ve monitörle işlenmesi gereken diğer çevreler için harikadır.}
\paragraph{Audacity}{ses dosyalarını düzenlemek için kullanılır, Windows ve Mac bilgisayarlarda da popülerdir.}
\paragraph{Cinelerra}{ve KDEnlive ya da OpenShot gibi programlar “düzgün-olmayan video düzenleyiciler” olarak bilinir ve dijital görüntü kaydedicilerden, TV alıcılarından, web kameralarından video alabilir bunları düzenleyip değişik efektler koyabilir ve çıktıyı istenen formata dönüştürebilirler.}
\paragraph{Blender}{sadece güçlü bir video düzenleyici değil ama ayrıca üç boyutlu görsel tasarımına izin veren bir programdır, profesyonel kalitede canlandırma filmler için kullanılabilecek bir yazılımdır.}

Bahsetmemiz gereken bir konu var, o da Linux olmadan bugünün patlamalı Holywood filmlerinden hiçbiri üretilemezdi. Büyük stüdyoların özel efekt “üretim çiftlikleri” nin hepsi Linux tabanlıdır.
\end{subsection}
\begin{subsection}{İnternet Servisleri}

Linux olmadan internet çok tanınır olmayabilirdi: Google' ın yüzbinlerce sunucusu dünyanın bütün dünyanın en büyük hisse senedi değişim ticaret sistemini çalıştırmak gibi görevlerde, istenen performans sadece Linux ile sağlanabildiği için Linux kullanır. Gerçek şu ki, çoğu internet yazılımı önce Linux' ta geliştirilir ve çoğu üniversite araştırmaları açık kaynaklı Linux platformu üzerinde olur.

\paragraph{Apache}{açık ara internetteki en popüler web sunucusudur, bütün web sitelerinin yarısından falzası bir Apache sunucusu üzerinde çalışır.}
\paragraph{MySQL ve PostgreSQL}{özgürce dağıtılan ilişkisel veritabanı sunucularıdır. MySQL web siteleri için en iyisiyken PostgreSQL bütün amaçlar için kullanılabilecek yenilikçi ve yüksek performanslı bir veritabanı sunucusudur.}
\paragraph{Postfix}{güvenli ve çok güçlü bir mail sunucusudur. Ev ofislerinden büyük ISP'lere ya da Fortune 500 listesindeki şirketlere kadar kullanılabilecek bir sistemdir.}
\end{subsection}
\begin{subsection}{Altyapı Yazılımları}

Bir Linux sunucusu yerel ağda çok kullanışlı olabilir: Güvenilirdir, hızlıdır ve düşük-bakım gerektiren yükleyip unutabileceğiniz bir yazılımdır. (düzenli yedeklemeler dışında tabi ki!)
\paragraph{Samba}{bir Linux makinesini Windows istemcileri için bir sunucuya dönüştürebilir. (Linux istemciler içinde bunu yapabilir elbette) Yeni Samba 4 ile bir Linux sunucusu Aktif Dizin alan kontrolcüsü olarak kullanılabilir. Güvenilirlik, performans ve cepte kalan lisans paraları oldukça ikna edicidir.}
\paragraph{NFS}{Samba için bir Unix ortamıdır ve ağdaki diğer Linux ve Unix makinelere Linux sunucu diskine erişimi sağlar. Linux geliştirilmiş performans ve güvenliği ile modern NFSv4' ü destekler.}
\paragraph{OpenLDAP}{orta ve büyük ağlar için bir dizin servisi görevi görür ve (serves as a directory service for medium and large networks and offers a large degree of redundancy and performance for queries and up-dates through its powerful features for the distribution and replication of data.)}
\paragraph{DNS ve DHCP}{temel ağ altyapısıdır. BIND ile birlikte Linux DNS sunucularını destekler ve ISC DHCP sunucusu çok büyük ağlarda bile istemcilere IP adresi gibi ağ parametrelerini sağlayabilir. Dnsmasq küçük ağlar için kullanması kolay bir DNS ve DHCP sunucusudur.}
\end{subsection}
\begin{subsection}{Programlama Dilleri ve Geliştirme}
Başlangıcından beri Linux hep geliştirme ortamları için geliştirilmiştir. Bütün önemli diller için derleyiciler ve yorumluyucular bulunur – GNU derleyici ailesi, örnek olara, C, C++, Objektif C, Java, Fortran ve Ada' yı destekler. Elbette Perl, Python, Tcl/Tk, Ruby, Lua ya da PHP gibi popüler betik dilleride desteklenir ve Lisp, Scheme, Haskell, Prolog ya da Ocaml gibi daha az yaygın kullanılan dillerde çoğu Linux dağıtımı tarafından desteklenir.

Çok zengin bir setten oluşan editörler ve yardımcı araçlar yazılım geliştirmeyi bir keyfe dönüştürür. Standart düzenleyici vi ve GNU Emacs ya da Eclipse gibi profesyonel geliştirme ortamlarıda Linux' ta hazırdır.

Linux ayrıca “gömülü sistemler” için olan geliştirme ortamları içinde uygundur, yani bilgisayarlar kullanıcının uygulamaları içinde çalışır bunlar Linux' un kendi temeline ya da özelleştirirmiş bir işletim sistemine dayanır. Bir Linux bilgisayarda, ARM işlemcilerde çalışacak makine kodunu üretecek bir derleyici ortamını yüklemek kolaydır. Linux ayrıca Android akıllı telefonları için yazılım üretilmesi için kullanılır ve bu amaç için kullanılaran araçlar Google tarafından özgürce dağıtılır.
\end{subsection}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Hangi Özgür Yazılım projelerini duydunuz? Hangilerini kendiniz kullandınız? Telif hakkıyla satılan alternatiflerinden daha iyi mi yoksa daha kötü mü olduklarını düşünüyorsunuz? Eğer öyleyse, neder? Öyle değilse, neden?
\end{itemize}}
\end{section}
\begin{section}{Önemli Linux Dağıtımları}
\begin{subsection}{Genel Bakış}

Eğer birisi “Bilgisayarımda Linux çalışıyor” derse genelde sadece Linux'u değil, Linux temelinde çalışan tamamlanmış bir yazılım ortamından bahsediyordur. Bu genelde kabuğu (bash) ve komut-satırı araçlarını, X.org görsel sunucuyu, KDE ya da Gnome görsel bir kullanıcı arayüzünü, LibreOffice, Firefox ya da Gimp gibi araçları ve diğer bir sürü kullanışlı programı içerir. Elbette bu araçların hepsinin Orijinal kaynakları internette bulunarak derlenebilir faka çoğu Linux kullanıcısı önceden yapılmış bir yazılım setini ya da bir “Linux dağıtımını” tercih eder.

Linux dağıtımı 1992' nin başlarında ortaya çıktı -- buunla birlikte bunlardan hiçbiri günümüzde geliştirilmiyor ve genellikle unutulmuş haldedirler. Hala çalışan en eski dağıtım olan Slackware ilk defa Temmuz 1993' te ortaya çıkmıştır.

Değişik amaç ve yaklaşımlara sahip birçok Linux dağıtımı bulunur. Bazı dağıtımlar şirketler tarafından dağıtılır ve muhtemelen sadece para için satılır, gönüllülük esasıyla geliştirilen dağıtımlarda bulunmaktadır. Bu bölümde en önemli genel amaçlı dağıtımları inceleyeceğiz.

Eğer en sevdiğiniz Linux dağıtımından bahsetmezsek bu onu beğenmediğimiz anlamına gelmez, sadece yerimiz ve zamanımızın kısıtlı olduğunu ifade eder. Eğer bir dağıtım listemizde yoksa bu onun kötü ya kullanışsız olduğu anlamına gelmez bu sadece o dağıtımın listemizde olmadığı anlamına gelir.

“DistroWatch” web sitesi (http://distrowatch.com/ ) en önemli Linux dağıtımlarını listeler ve dağıtım-yönelimli haberleri sağlar. Şu anda 317 tane dağıtımı içeriyor (evet tam üçyüzonyedi tane!) ama bunu okuduğunuz süre içerisinde muhtemelen bu rakam doğru olmayacak.
\end{subsection}
\begin{subsection}{Red Hat}

Red Hat (http://www.redhat.com/ ) 1993 yılında Linux ve Unix araçları sağlayan bir dağıtım şirketi olan “ACC Corporation” tarafından ortaya çıkarıldı. 1995' te şirket kurucusu, Bob Young, 1994' te Red Hat Linux diye adlandırılan bir Linux dağıtımını ortaya çıkaran Marc Ewing' in şirketini satın aldı ve onun şirketinin adını “Red Hat Yazılım” olarak değiştirdi. 1999' da Red Hat halka sunuldu ve şu an muhtemelen sadece Linux ve özgür yazılım tabanlı olan en büyük şirket.

Red Hat orijinal bireysel müşteri marketinden çekildi (son Red Hat Linux 2004' te yayınlandı) ve şimdi “Red Hat Enterprise Linux” (RHEL) adı altında şirketler için profesyonel bir dağıtım ile pazara girdi. RHEL sunucu başına lisanslanmıştır ama yazılıma para ödemezsiniz – GPL ve benzer özgür yazılım lisansları ile gelmektedir bunlar-- ama zamanlanmış güncellemeleri ve problem desteği için para ödersiniz. RHEL veri merkezleri için çokça tercih edilir ve diğerleri dışında hata dayanıklılığı için destek verir. (uygun ek araçlarla)

“Fedora” (http://www.fedoraproject.org/ ) büyük kısmı Red Hat tarafından kontrol edilen bir dağıtımdır ve RHEL için bir “deneme yatağı” olarak hizmet eder. Yeni yazılım ve fikirler önce Fedora' da denenir ve kullanışlı olduğu ortaya çıkanlar er ya da geç RHEL' de yerini alır. RHEL' in aksine Fedore satılmak yerine internette bedava olarak indirilebilir haldedir, proje bir kısmı Red Hat bir kısmı camia geliştiricileri olan bir komite tarafından sürdürülür. Çoğu Fedore kullanıcısı için var olan yazılımlara odaklanmak ve yeni fikirler dağıtımın cazibeli kısmıdır, hatta bu sık sık gelen güncellemeler anlamına gelse bile. Fedora başlangıç seviyesi kullanıcıları ve güvenilir olması gereken sunucular için çok uygun değildir.

Red Hat yazılımlarını GPL gibi özgür yazılım lisansları altında dağıttığı için Red Hat' a lisans bedelini ödemeden aynı işlevleri gören bir sistem edinmek mümkündür. CentOS (http://www.centos.org/ ) ya da Scientific Linux (https://www.scientificlinux.org/ ) gibi dağıtımlar genelde RHEL tabanlıdır ama bütün Red Hat markası silinmiştir. Bu temelde aynı yazılımı Red Hat desteği olmadan elde etmeniz anlamına gelir.

CentOS özel olarak RHEL' e çok yakındır ve Red Hat size CentOS makineleriniz için destek satmaktan mutlu olacaktır. Bunun için RHEL yüklemenize bile gerek kalmaz.

\end{subsection}
\begin{subsection}{SUSE}

Alman şirketi SUSE “Gesellschaft für Software- und System-Entwicklung” ismi altında Unix desteği veren bir firma olarak 1992 yılında kuruldu. Ürünlerinden biri Patrick Volkerding’in Linux dağıtımı idi, ilk tamamlanmış Linux dağıtımı olan Slackware' den türetilmişti. Yavaş yavaş Red Hat' ten RPM paket yönetimi ya da /etc/sysconfig dosyası gibi bazı özellikler alarak Slackware' den ayrılmaya başladı. Slackware gibi görünmeyen ilk S.u.S.E sürümü 1996' nin sürüm 4.6'sı idi. SuSE(isimdeki noktalar bir zaman sonra kayboldu) kısa sürede Alman dilindeki bir Linux dağıtımı olarak öne çıktı ve “Kişisel” ve “Profesyonel” olmak üzere iki tane toplu set halinde dağıtılmaya başlandı.

Kasım 2003' te Amerikan yazılım şirketi Novell SuSE' yi 210 milyon dolara aldığını ilan etti; anlaşma sonuçlandırıldı. (Bu noktadan sonra SuSE SUSE olarak değişti) Nisan 2011' de Novell SuSE ile birlikte Attachmate adlı bir firma tarafından alındı, bu firma terminal emülatörleri, sistem monitörleme ve uygulama taşıma ve Linux ve açık kaynak camiaları tarafından önceden keşfedilmemiş işler yapıyordu. O zamandan beri Novell birisi SUSE olmak üzere iki ayrı iş kolunda çalışmaya devam etti. araçları konusunda çalışıyordu.

Red Hat gibi SUSE' de bir şirket Linux' u önerir, SUSE Linux Enterprise Server (SLES, http://www.suse.com/products/server/ ). Ayrıca SUSE Linux Enterprise Desktop (SLED) dağıtımıda bulunur, bu dağıtım masaüstü iş istasyonlarında kullanılmak üzere tasarlanmıştır. SLES ve SLED içerdikleri paketler açısından değişiklik gösterirler; SLES daha çok sunucu yazılımına yönelikken SLED daha interaktif yazılımları kullanır.

Şekil 2.2: Debian Projesinin örgütsel yapısı

SUSE' de, bireysel kullanıcılar için bir dağıtım çıkarıyor ve bu serbestçe kullanılabilir bir durumdadır, “openSUSE” (http://www.opensuse.org/), eski zamanlarda dağıtım optik medyalarda dağıtıldıktan birkça ay sonra indirmek için internete konulurdu. Red Hat' in aksine SUSE hala lisanslı ürünler içeren paket ürünler satar. Fedora' nın aksine openSUSE hala kısa yaşam süreleri içeren ciddi bir platformdur.

SUSE dağıtımının fark edilir ürünlerinden biri kapsamlı bir grafiksel sistem yönetim aracı olan “YaST” dır.

\end{subsection}
\begin{subsection}{Debian}

İki büyük Linux dağıtımı firması olan Red Hat ve Novell/SUSE' nin aksine Debian projesi (www.debian.org) amaçları yüksek kalite bir Linux dağıtımı olan ve Debian GNU/Linux olarak adlandırılan bir dağıtımı herkes için kullanılabilir yapmak olan gönüllülerin çalışmasının bir sonucudur. Debian projesi Ian Murdock tarafından 16 Ağustos 1993 yılında duyuruldu, isim kendi ismi ile o zamanlar kız arkadaşı (şimdi eski karısı) olan Debra' nın isimlerinin bir birleşimi olarak ortaya çıktı. (Bu sebeple debb-ian olarak telaffuz ediliyor) Şu anda proje 1000' den fazla gönüllü yardımına sahiptir.

Debian üç belgeye dayanmaktadır:

\begin{itemize}
 \item Debian Özgür Yazılım Kılavuzları (DFSG – Debian Free Software Guidelines) hangi yazılım projesinin özgür olarak kabul edilebileceğini tanımlar. Bu önemlidir, çünkü sadece DFSG-özgür yazılımları Debian GNU/Linux dağıtımına kesin olarak katılabilir. Proje ayrıca özgür olmayan yazılımlarıda içerir, bunlar dağıtımın sunucusunda DFSG özgür yazılımlarından kesin bir şekilde ayrı tutulur. İkincisi main diye adlandırılan alt dizinin non-free bölümündedir. (contrib olarak adlandırılan bir orta alan bulunur, bu bölüm kendi içinde DFSG yazılımı olup özgür olmayan yazılımlar olmadan çalışamayan yazılımları içerir.
 \item Toplumsal Sözleşme projenin amaçlarını tanımlar.
 \item Debian Tüzüğü projenin organizasyon kısmını tanımlar. (Şekil 2.2' ye bakınız)
\end{itemize}

Herhangi bir zamanda Debian GNU/Linux' un en az üç sürümü bulunur. Yeni ya da düzeltilmiş sürüm paketleri unstable bölümüne konulur. Eğer belirli bir zaman aralığında pakette önemli hatalar olmadığı anlaşılırsa bu testing bölümüne kopyalanır. Genelde testing bölümünün içeriği “dondurulmuş” olarak geçer ve çok ayrıntılı bir şekilde test edilir. En sonunda stable olarak yayınlanır. Debian GNU/Linux' un en sık eleştirilen özelliklerinden birisi stable sürümler arasındaki zaman uzunluğudur, ama genelde bu bir avantaj olarak kabul edilir. Debian projesi sadece Debian GNU/Linux' u indirmeye sunar; medyalar üçüncü parti üreticilerden sağlanır.

Organizasyonunun bir fazileti olarak, özgür olması ve özgür ve özgür olmayan yazılımlar arasında temiz bir ayrım yapması nedeniyle Debian GNU/Linux türetilmiş projeler için bir temeldir. Bu türetilmiş projelerden en popülerleri Knoppix (Linux' u yüklemeden deneyebileceğiniz bir Live CD), SkoleLinux (özellikle okullar için ayarlanmış bir Linux sürümü) ya da ticari bir sürüm olan Xandros' tur. Limux' da, Münih şehir yönetimince kullanılan masaüstü Linux türevi, bir Debian GNU/Linux türevidir.

\end{subsection}
\begin{subsection}{Ubuntu}

En popüler Debian türevlerinden biri olan Ubuntu Güney Afrikalı bir girişimci olan Mark Shuttleworth tarafından bir İngiliz firması Canoncial Ltd. aracılığı ile sunulmuştur. (“Ubuntu” kelimesi Zulu dilinden gelmektedir ve kabaca “insanlık” demektir.) Ubuntu' nun amacı Debian GNU/Linux tabanlı düzenli aralıklarla güncellenen güncel, yetenekli, anlaması-kolay bir Linux sürümü sunmaktır. Örnek olarak Debian on ya da daha fazla mimariye yönelik çalışabilmesine rağmen Ubuntu sadece üç mimariye hizmet sunar.

Ubuntu, Debian GNU/Linux' un kararsız sürümüne dayanır ve büyük bir parçası yazılımlar için aynı araçları kullanır ama Debian ve Ubuntu yazılım paketleri her zaman için karşılıklı olarak uyumlu olmak zorunda değildir. Ubuntu her altı ayda bir döngüde yeni sürüm yayınlar ve her iki yılda beş yıl boyunca güncelleme alan bir uzun-süreli-destek (LTS – long-term support) sürüm sunar.

Bazı Ubuntu geliştiricileri ayrıca Debian projesinde de aktif olarak katılımcıdır ve bu belli derecede yazılım alışverişini destekler. Ama bütün Debian geliştiricileri yaratıcılık adına yaptığı kısaltmalar konusunda çok hevesli değildir, çünkü Debian çok çaba gerektirsede kapsamlı çözümleri arar. Ek olarak Ubuntu Debian kadar kendisini özgür yazılıma borçlu hissetmez; Debian' ın tüm altyapu yazılımları özgürce bulunabilecekken bu Ubuntu için her zaman geçerli değildir.

Ubuntu çekici bir masaüstü sistemi olmak dışında RHEL ya da SLES gibi sunucu alanında daha yerleşik bir sistem olmanın peşinde ve bunu uzun süreli sürümler ve iyi bir destek sunarak yapmayı planlıyor. Canoncial şirketinin bundan nasıl para kazanacağı pek belli değil, proje başladığından beri genelde Mark Shuttleworth'un kendi internet sertifika kanıtlamasını, Thawte, Verisign'a sattığındandan beri iyice dolmuş olan özel kasasından destekleniyor.

\end{subsection}
\begin{subsection}{Diğerleri}

Burada bahsettiğimiz dağıtımların dışında birçok dağıtım bulunmaktadır. Red Hat ve SUSE' nin küçük rakipleri Mandriva Linux ya da Turbolinux bunlardan bazılarıdır. Gentoo gibi kaynak koduna odaklanan sürümlerde bulunmaktadır. Güvenlik duvarlarından oyunlara ya da çoklu ortam platformlara ya da çok karışık sistemler için kullanılabilecek birçok değişik amaç için birçok değişik “çalışan sistemler” bulunmaktadır.

Ayrıca Linux dağıtımı olarak kabul edilebilecek Android'den de bahsetmek gerekir. Android Google tarafından sağlanan ve Google' ın Java sürümüne (Dalvik) dayanan bir kullanıcı uzayı ortamı (GNU, X, KDE gibi normal dağıtımlarda bulunan kullanıcı arayüzleri yerine) barındıran bir Linux işletim sistemi çekirdeği taşır. Bir Android telefonu ya da tableti kendisini kullanıcıya Debian ya da openSUSE' nin çok aksi bir yönde tanıtır ama yinede tartışılabilir bir şekilde bir Linux sistemidir.

Çoğu Android kullanıcısı sistemlerini telefon ya da tabletlerine yüklenmiş olarak alıp hiç değiştirmiyorlar bu sistemi ama çoğu Android tabanlı cihazlar (bazen hackleme ile) varolan alternatif bir Android sürümünün yüklenmesine izin verir. Çoğu cihaz için en güncel Android sürümünü elde etmenin yolu cihaz üreticisinin ya da telefon servis sağlayacısının resmi bir güncel sürüm yayınlaması ile olur.

\end{subsection}
\begin{subsection}{Farklılıklar ve Benzerlikler}

Çok fazla Linux dağıtımı olmasına rağmen en azından büyük dağıtımların günlük hayatta kullanımları oldukça benzer hale geldi. Bu bir parça neredeyse aynı temel programları kullanıyor olmalarından dolayıdır – örneğin komut satırı yorumlayıcısı neredeyse her zaman bash olarak bulunur. Diğer açıdan bakıldığında standartlar büyüme hızını kısıtlamaya çalışır. Bu Dosya Sistemi Hiyerarşi Standardı ya da Linux Standart Tabanını kapsar, LST üçüncü parti yazılımların oldukça fazla Linux sürümünde kullanılabilmesi için Linux' un temel bir sürümünün bulunması gerektiğini söyler.

Ne yazık ki, LST beklenildiği ve olması gerektiği gibi bir başarı olmadı – sık sık Linux' un gelişimini yavaşlatmak ya da durdurmak amaçlı olduğuna dair yanlış anlaşıldı ve çeşitliliği azaltmak (çoğu dağıtımlar LST ortamını kendi ortamlarıyla aynı anda paralel olarak sunsa bile) hedeflenen üçüncü parti yazılımları kendisine çekmek için tasarlanmıştı ancak bu yazılımlar kendi yazılım paketlerini genelde RHEL ve SLES gibi ana şirket dağıtımları için kullanılabilir hale getirdi ve sadece bu ortamları desteklemeye başladı. SAP ya da Oracle' ı diyelim ki Debian GNU/Linux üzerinde çalıştırmak mümkün olsa da, RHEL ve SLES için yapılan lisans harcaması ile bu büyük yazılım paketleri için yapılacak lisanslama bedeli temel olarak çok fark edilebilir bir fark yaratmaz.

Dağıtımların farklı olduğunun fark edildiği bir alan yazılım paketlerinin yönetilmesi (yükleme ve kaldırma) ve dağıtımla gelen paketlerin dosya biçimidir. Bu konuda iki genel yaklaşım bulunur. Birisi Debian GNU/Linux (“deb”) ve diğeri de Red Hat (“rpm”) tarafından geliştirilen dosya biçimidir. Genel olarak ikiside birbirine açıkça bir üstünlük sağlamaz ama yine de güçlü yönleri değişimlerini engellemektedir. Deb yaklaşımı Debian, Ubuntu ve diğer Debian türevlerinde kullanılırken Rad Hat, SUSE ve bunlardan geliştirilen dağıtımlar rpm üzerinde çalışır.
\paragraph{Tablo 2.1: En önemli Linux dağıtımlarının karşılaştırması (Şubat 2012 itibariyle)}{ --}

İki yaklaşımda yazılım paketleri arasındaki bağımlılıklarda sistemi kararlı tutmaya yardımcı ve sistemde bir paketin silinmesinde diğerlerinin bağlılıklarının silinmemesini sağlayan oldukça kapsamlı bir bağımlılık yönetimi sunar. (ya da bir yazılımın bağımlılıkları önceden kurulmuşsa bunların tekrar kurulmamasını sağlar.)

Windows ve OS X kullanıcıları yazılımlarını bazı kaynaklardan elde ederler. En azından Debian, openSUSE ya da Ubuntu gibi büyük dağıtımlar kullanıcılarına çok kapsamlı bir listeden direkt olarak paket yönetim araçlarıyla program kurabilmelerine olanak sağlarlar. Bu dağıtımların depolarına erişime izin verir ve bir ağ üzerinden bağlılıkları ile birlikte bir programın kurulabilmesi için arama seçeneği sunar.

Aynı temel paket biçimlerini kullansalarda (deb ya da rpm) her zaman dağıtımlar arasında paketleri kullanmak mümkün değildir – paketler paket biçimlerinden daha çok dağıtımların nasıl çalıştığı ile ilgili bilgiler içerir. Bu tümüyle yapılamaz bir durum değildir elbette (örneğin Debian GNU/Linux ve Ubuntu doğru koşullarda birbirlerinin paketlerini kullanabilir) ama bir kural olarak, bir sistem ne kadar sistemde derine etki ediyorsa bir sorun oluşması o kadar büyüktür – sadece birkaç çalıştırma satırı içeren programlar ve onların belgeleri daha az sorun yaratırken makinanın başlangıç servisine gönderilen bir sistem servisi çok daha fazla sorun yaratabilir.

Tablo 2.1 en önemli Linux dağıtımlarının genel özelliklerini gösterir. Daha fazla bilgi için DistroWatch'a ya da dağıtımların kendi internet sitelerine göz atmanızı tavsiye ederiz.
\paragraph{Özet}{
\begin{itemize}
 \item İlk Linux sürümü Linus Torvalds tarafından geliştirilip özgür yazılım olarak internette yayınlandı. Bugün dünya genelindeki yüzlerce geliştirici sistemi güncellemek ve geliştirmek için birlik oluyorlar.
 \item Özgür yazılım, yazılımları istediğiniz amaçlar için kullanmanıza olanak sağlar, kodu değiştirebilirsiniz ve başka insanlara değiştirilmiş ya da değiştirilmemiş kopyaları dağıtabilirsiniz.
 \item Özgür yazılım lisansları alıcıya başka türlü sahip olamayacakları hakları verir çünkü genelde lisans anlaşmaları alıcının haklarını kısıtlamaya yöneliktir.
 \item GPL çok popüler bir özgür yazılım lisansıdır.
 \item Özgür yazılım için olan diğer yaygın lisanslar bulunmaktadır. BSD lisansı, Apache lisansı ya da Mozilla Genel lisansı bunlara dahildir. Yaratıcı-yaygınlık lisansı yazılım dışında kültürel işler için kullanılır.
 \item Her amaç için kullanılabilinecek çok geniş bir ölçekte özgür ve açık kaynak kodlu yazılım bulunmaktadır.
 \item Birçok farklı Linux dağıtımı bulunmaktadır. Bunlardan en popüler olanları Red Hat ve Fedora, SUSE ve openSUSE, Debian ve Ubuntu'dur.
\end{itemize}}
\end{subsection}
\end{section}
\chapter{Linux ile İlk Adımlar}


\chapter{Kim Korkar Kabuktan}
\paragraph{Amaçlar}
\begin{itemize}
 \item Komut-satır kullanıcı arayüzünün önemini anlamak
 \item Bourne-Again Shell(Bash) komutları ile çalışmak
 \item Linux komutlarının yapısını anlamak
 \end{itemize}
 
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Temel bilgisayar bilgisi işe yarar olacaktır.
 \end{itemize}

\begin{section}{Neden?}

Linux, diğer modern işletim sistemlerine göre klavye ile metinsel komutlar girme fikrine dayanır. Windows tarzı sistemler kullananlar için çok eski bir teknik gibi gelebilir, hatta Linux'e Windows'tan gelen çoğu kişiler için komut satır arayüzü "kültür şoku" gibidir.

Ama herşey o kadar göründügü gibi kötü değil. Günümüzde Linux için de Windows'ta, Mac OS X'te olduğu gibi onlara eşit veya bazı noktalarda daha iyi kullanım sunan görsel arayüzler var. Öte yandan, görsel arayüzler ve metin odaklı komut satırı birbirini dışlayan değil, aslında tamamlayıcıdırlar ("Her iş için doğru araç" felsefesine göre).

Günün sonunda gelişmekte olan Linux kullanıcısı olmak dışında aynı zamanda "kabuk" olarak bilinen metin odaklı kullanıcı arayüzüne alışmış olacaksınız. Kimse sizin görsel masaüstü kullanmanızı engellemez. Ancak, kabuk ile yapabileceğimiz son derece güçlü, karmaşık operasyonları görsel olarak yapmak oldukça güçtür. Kabuğu ihmal etmek arabanın birinci vitesi dışında tüm viteslerini gereksiz saymak gibidir
\footnote{Bu metafor manuel vites kullanan Avrupalılar ve diğer insanlar içindir; bizim Amerikan okuyucularımız tabi ki otomatik vites kullanırlar.
Hepsinin Windows kullanıyor olması gibi}. Tabi ki birinci vitesle de ulaşmak istediğiniz yere ulaşırsınız fakat bu zaman kaybına ve gereksiz gürültüye sebep olur. Pekala, bu işlemin Linux'ta nasıl yapıldığını niçin ögrenmeyelim? Şimdi iyice dikkat ederseniz size bu konuyla ilgili birkaç püf noktası aktaralım.

\begin{subsection}{Kabuk nedir?}

Kullanıcılar doğrudan doğruya işletim sisteminin çekirdeğiyle iletişim kuramazlar. Bu sadece "sistem çağrıları"nı kullanan programlarla mümkündür. Ancak, bir şekilde bu tür programları başlatabiliyor olmanız gerekir. Kabuk, klavyeden girilen komutları (genellikle) okuyup onları çalıştırılabilir hale getiren, özel bir kullanıcı programı olarak bu görevi üstlenir. Kabuk, bilgisayara "arayüz" hizmeti vererek asıl işletim sisteminin kabuğunu örter. Tabi ki kabuk, işletim sistemine erişen programlar arasından sadece bir tanesidir.

Bugünün görsel "masaüstü" de "kabuk" olarak kabul edilebilir, örneğin KDE gibi. Klavyeden girilen komutlar kabuk tarafından belli bir dil bilgisi kuralına göre işleme konur; aynı şeyi görsel masaüstü, komutları fareden alarak gerçekleştirir. Örneğin, fare yardımıyla nesneleri tıklayarak seçersiniz ve ne yapacağınıza karar verirsiniz: açmak, kopyalamak, silmek vs.

Hatta 1960 Unix modelinde bile kabuk vardı. En eski kabuk 1970'lerin ortalarında "Unix'in 7. sürümü" için Stephen L.Bourne tarafından geliştirildi. "Bourne kabuğu" olarak isimlendirilen bu kabuk temel işlevleri yerine getirip yaygın olarak kullanılıyordu, ama bugün bu kabuk orijinal haliyle nadiren görülür. (C kabugu) Diğer klasik Unix kabukları C kabuğunu içerir, bu kabuk Berkeley'de bulunan California Üniversitesi'nde C programlama dili ile oluşturuldu ve büyük ölçüde Bourne kabuğu ile uyumlu olmasına rağmen daha işlevsellik açısından daha gelişmiş (David Korn tarafından geliştirildi, AT\&T'de de geliştirildi).

Linux sistemlerinde standart Bourne-again shell kabuğudur, kısacası bash. Bu kabuk, Brian Fox ve Chet Ramey tarafından Özgür Yazılım Vakfı'nın GNU projesi altında geliştirilmiş olup, Korn ve C kabularının birçok işlevlerini
birleştirir.

Bahsettiğimiz kabukların haricinde başka kabuklar da mevcuttur. Unix'te, kabuk diğer programlar gibi sıradan bir uygulama programıdır,
üzerine yazmak için ek olarak ayrıcalığa gerel yoktur - sadece kabuğun diğer programlarla nasıl iletişim kurması gerektiği yönetmeliğinin 
kurallarına bağlı kalmanız yeterlidir.

Kabuklar kullanıcı komutlarını okumak için etkilesimli olarak çağrılabilirler (genellikle "terminal" üzerinde). Pek çok kabuk bir de dosyadan komut dizilerini okuyabilir. Bu tür dosyalara "kabuk betikleri" denir.
\paragraph{}{Kabuk aşağıdaki adımları takip eder:
\begin{itemize}
\item Terminalden (veya dosyadan) komut okumak
\item Komutları onaylamak
\item Komutu doğrudan doğruya çalıştırmak veya karşılık gelen programı çalıştırmak
\item Sonucu ekrana (veya başka yere) vermek
\item 1. adımdan devam etmek
\end{itemize}}

Standart komut döngüsü dışında, kabuk genellikle programlama dili gibi ilave özellikler de içerir. Bu da karmaşık komut yapıları, koşulları ve değiskenleri içerir. Son zamanlarda kullanılan komutlar yeniden kullanabilme kullanıcının hayatını kolaylaştırmaktadır.

Kabuk oturumları genellikle "exit" komutu ile sonlandırılabilir. Bu işlem oturum açtıktan hemen sonra elde ettiğimiz kabuk için de geçerlidir.

Daha önce de bahsettiğimiz gibi birçok kabuk vardır. Ama biz çoğu Linux dağıtımında gelen standart kabuk olan "bash" üzerinde odaklanalım. LPI sınavları da özellikle bash'e işaret eder.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item 2 Oturumunu kapatın ve tekrar açın, sonra "echo \$0" komutun çıktısını giriş kabuğunda kontrol edin. "bash" komutu ile yeni bir kabuk başlatın ve "echo \$0"i tekrar girin. Iki komutun çıktısını karşılaştırın. Alışılmadık herhangi birşey farkettiniz mi?
\end{itemize}}
\end{subsection}
\end{section}
\begin{section}{Komutlar}
\begin{subsection}{Neden komutlar?}
\paragraph{}{Bir birgisayarın eylemleri, işletim sistemi ne olursa olsun üç adımla tanımlanabilir:
\begin{itemize}
 \item Bilgisayar kullanıcının veri girmesi için bekler
 \item Kullanıcı komut seçer ve klavye ya da fare aracılığıyla komutu girer
 \item Bilgisayar komutu gerçekleştirir
\end{itemize}}

Linux sisteminde kabuk bir "istemi" görüntüler, bu da komutların girilebileceğini gösterir. Bu istem genellikle geçerli bir kullanıcı ve host (bilgisayar) adını, bulunduğumuz geçerli dizini ve son karakteri içerir:
\begin{verbatim}joe@red:/home $>$ \_
\end{verbatim}

Bu örnek,"joe" kullanıcısının "red" adındaki bilgisayarın "/home" dizininde bulunduğunu ifade etmektedir.
\end{subsection}
\begin{subsection}{Komut Yapısı}

Bir komut aslında karakterler dizisinden oluşur ve enter tuşuna basılmasıyla komut, kabuk tarafından değerlendirilir. Çogu komut Inglizce'den esinlenilerek "komut diline" verilmiş bir şekildir. Bu dilde komutlar belli kurallara, "sözdizimine" uymalıdır ki kabuk bunları yorumlayabilsin.

Kabuk komut satırını yorumlayabilmek için ilk önce satırı sözcüklere ayırır. Gerçek hayatta olduğu gibi sözcükler bosluklarla ayırılır. Satırdaki ilk sözcük genellikle asıl komuttur. Satırdaki geri kalan sözcükler detaylı olarak ne yapılmak istendiğini belirten parametrelerdir.

Kabuğun büyük ve küçük karakterleri birbirinden ayırabiliyor olması DOS ve Windows kullanıcılarını şaşırtabilir. Linux komutları genellikle sadece küçük harflerle (istisnaları kanıtlama kuralı) yazılır. Ayrıca 4.2.4'e bakın.

Komutları sözcüklere ayırırken, kabuk için sözcüklerin arasında bir veya daha fazla boşluk karakterinin olması aynı şeydir. Aslında, kabuk için sözcükler arasında boşluk karakterinin olup olmamasının önemi yoktur; tabulator karakterine de izin verilmiştir. Bu karakterin önemi de komutları dosyalardan okurkendir, çünkü kabuk doğrudan doğruya tab karakterini girmeye izin vermez (en azından çemberleri atlamadan).

Bilgisayara girdiğiniz komut tek satıra sığmayacaksa bunu birkaç satırda ifade etmek de mümkün. Ama bunun bir komut girdisi olarak  anlaşılmaması için satır sonlandırıcıdan önce (enter) "Token \" karakteri yazılmalıdır. Komutların parametreleri kabaca ikiye ayırmak mümkündür:
\begin{itemize}
 \item Tire("-") ile başlayan parametreler seçenekler diye isimlendirilir. Bunlar genelde, isteğe bağlıdır, detaylar söz konusu komuta göre değisir. Bunlara mecazi olarak "anahtarlar" demek mümkündür. Bunlar komutun bazı özelliklerinin açılıp kapanmasını sağlarlar. Eğer komuta birkaç tane seçenek eklenmek istenirse bunları ayrı ayrı tire karakteri ("-a -l -F") ile yazabileceğimiz gibi tek tire karakteri ile de yapılabilir ("-alF"). Konsol komutları birden fazla seçenek alabilir. Bunların bazısı tek karakterle yazılabilen seçenekler olurken kimisi okunabilirliği arttırmak için uzun şekilde yazılan seçeneklerdir. Uzun seçenekler çoğu zaman iki tire karakteri ile başlarlar ve birleştirilemezler: "foo --bar --baz".
 \item Tire ile başlamayan parametreler "delil" olarak adlandırılır. Bu da çogu zaman komutun işlemesi gerektiği dosyanın adına karşılık gelir
\end{itemize}

\paragraph{}{Genel komut yapısı aşağıdaki gibi gösterilebilir:
\begin{itemize}
\item Komut - "Ne yapılacak?"
\item Seçenekler - "Nasıl yapılacak?"
\item Deliller - "Ne ile yapılacak?"
\end{itemize}
}
\end{subsection}

Genellikle seçenekler komutlardan sonra, delillerden önce gelir. Ancak, komutların tümü bu şekilde kuralın işlemesini şart koşmazlar. Bazıları delil ve seçenekleri keyfi olarak karıştırabilirler ve onlar, bütün seçenekler komuttan sonra gelmiş gibi davranırlar.Komut satırı sırayla işlenirken -*-*diğerleriyle karşılaşıldığında seçenekler de dikkate alınır.

Geçerli Unix sistemlerinin (Linux dahil) komut yapısı 40 yıllık bir süreç içinde büyük bir gelişme sağladı ve bu nedenle bazen çeşitli tutarsızlıkların ve küçük sürprizlerin görülmesi doğaldır. Biz de daha tutarlı olması gerektiğine inanıyoruz ama 30 yıllık geçmişe sahip kabuk betiklerini tamamen göz ardı etmek zordur. Bu nedenle sık sık görülen küçük garipliklere hazırlıklı olun.

\begin{subsection}{Komut Tipleri}
\paragraph{Dahili komutlar}{Bu komutlar kabuğun kendisi tarafından sunulmaktadır. Bourne-again hızlı gerçekleştirilebilen 30 kadar dahili komut içerir. Kabuğun durumunu degiştiren bazı komutlar (exit veya cd gibi) dışarıdan temin edilemez.}
\paragraph{Harici komutlar}{Kabuk bu tür komutları kendi kendine çalıştırmaz ama çalıştırılabilir dosyaları başlatır. Ki bu tür dosyalar genelde /bin veya /usr/bin dizinleri altında bulunurlar.Bir kullanıcı olarak kendi programlarınızı temin edip kabuğun diğer tüm harici komutları çalıştırdığı gibi kendi programlarınızın çalıştırılmasını sağlayabilirsiniz. Komutunuzun türünü öğrenmek için "type" komutunu kullanabilirsiniz. Bu komuta delil olarak komut adı verirseniz çıktı olarak size komutun türünü ya da karşılık gelen dosya ismini verir, örneğin}
\begin{verbatim}
 $ type echo
 echo is a shell builtin
 $ type date
 date is /bin/date
\end{verbatim}

("echo" komutu ilginç bir komut olup kendisine verilen parametreleri çıktı olarak verir:

\begin{verbatim}
 $ echo Thou hast it now, king, Cawdor, Glamis, all
 Thou hast it now, king, Cawdor, Glamis, all
\end{verbatim}

"date" komutu da geçerli tarih ve saat olarak ayarlanmış olan saat dilimi ve dile göre gösterir:

\begin{verbatim}
 $ date
 Mon May 7 15:32:03 CEST 2012
\end{verbatim}

echo ve date komutları hakkında daha fazlası için 9. Bölüme bakınız.)

"help" komutuyla dahili Bash komutları ile ilgili bilgiyi alabilirsiniz: 
\begin{verbatim}
 $ help type
 type: type [-afptP] name [name ...]
   For each NAME, indicate how it would be interpreted if used as a
   command name.
   
   If the -t option is used, `type' outputs a single word which is one of
   `alias', `keyword', `function', `builtin', `file' or `', if NAME is an
\end{verbatim}
\paragraph{Alıştırmalar}{
\begin{itemize}
\item Aşağıdaki programlardan hangileri bash ile harici ve hangileri dahili olarak temin edilir: \begin{em}alias, echo, rm, test\end{em}?
\end{itemize}
}
\end{subsection}
\begin{subsection}{Daha da fazla kurallar}
Yukarıda belirtildigi gibi, kabuk, komut girildiğinde büyük-küçük harflere duyarlıdır. Bu durum sadece komutlar için geçerli olmayıp seçenekleri ve parametreleri (çoğunlukla dosya isimlerini) de kapsar.

Şunu da göz önünde bulundurmalısınız ki kabuk bazı karakterleri özel giriş karakterleri olarak algılar. En önemlisi de daha önce belirtilmiş olan
boşluk karakteri komut satırındaki sözcükleri ayırmak için kullanılmaktadır. Özel anlamı olan diğer karakterler şunlardır:

\begin{verbatim}
 $&;(){}[]*?!<>"'
\end{verbatim}

Tabi bunları kullanmak isteyebiliriz. Bu durumda onlar kabuk tarafından özel karakterler gibi yorumlanmasın diye karakterlerin önüne "$\backslash$" işareti eklenir. "$\backslash$" işareti ile sadece tek bir özel karakteri kabuktan kaçırabilirsiniz. Birden fazla özel karakterin kaçırılması içinse tek tırnak yada çift tırnak ('...',"...") kullanılır. Örneğin:

\begin{verbatim}
 $ touch 'New File'
\end{verbatim}

Tırnak işareti olduğu için komut tek bir dosya olan "New File" için geçerlidir. Tırnak işareti olmasaydı "New" ve "File" diye iki ayrı dosya olarak algılanırdı.

Burada özel karakterlerin hepsini açıklayamayız. Çoğu bu kilavuzun farklı yerlerinde karşımıza çıkacaktır ya da Bash belgelerini kontrol edin.

\paragraph{Bu bölümdeki Komutlar}{
\begin{itemize}
\item bash 	"Bourne-Again-Shell" - etkileşimli komut yorumlayıcısı
\item date 	Tarihi ve zamanı görüntüler
\item echo 	Boşlukla ayrılan tüm parametrelerini standart çıktıya yazar
\item help	bash komutları için yardımı görüntüler
\item type 	Komutun türünü gösterir (dahili, harici, takma ad)
\end{itemize}}
\paragraph{Özet}{
\begin{itemize}
\item Kabuk kullanıcı komutlarını okur ve onları çalıştırır.
\item Çoğu kabukta programlama dilinin özellikleri vardır. Ayrıca komut dizileri içeren kabuk betiklerini destekler.
\item Komutlar delil ve seçeneklere sahip olabilir. Seçenekler komutun nasil çalistigini belirlerken deliller ne üzerine çalıştığını belirler.
\item Kabuklar dahili komutları ve harici komutları ayırt edebilir.
\end{itemize}}
\end{subsection}
\end{section}

\chapter{Yardım Almak}
\paragraph{Amaçlar}
\begin{itemize}
 \item Kılavuz ve Bilgi sayfalarıyla çalışabilmek
 \item Nasıl Yapılır kısmını anlamak ve onları bulabilmek
 \item Diğer en önemli bilgi kaynaklarına aşina olmak
 \end{itemize}
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Linux'a genel bakış
 \item Temel Linux komut satırı kullanımı (örneğin daha önceki bölümlerde bahsedilenler)
\end{itemize}
\begin{section}{Kendi kendine yardım}

Linux güçlü ve dallı budaklı sistemdir. Kural olarak güçlü ve dallı budaklı sistemler karışıktır. Belgeler, bu karmaşıklığı yönetebilmek için önemli bir araçtır. Birçok (ne yazık ki hepsi değil) Linux dağıtımı geniş olarak belgelenmiş olarak gelir. Bu bölümde bu belgelere nasıl ulaşılacağının bazı yötemlerini açıklar.

Linux'da "help" birçok durumda "self-help" anlamına gelir. Özgür Yazılımın kültüründe toplulukta boş zamanlarını geçiren diğer insanların  
zamanını ve iyi niyetini kılavuzun ilk birkaç paragrafında zaten açık olarak anlatılmış olan şeyleri sormamanıza dikkat çeker. Linux kullanıcısı
olarak sizin de mevcut belgelere en azından kısaca gözden geçirmiş olmak ve gerektiğinde yardım kısmını elde edinebilmelisiniz. Eğer siz size düşeni
yaparsanız yani ödevinizi yaparsanız göreceksiniz ki genellikle insanlar çıkmaza girdiğinizde yardım edeceklerdir. Ama baskalarının onların yerine
işlerini yapmasını bekleyen tembel bireyler hoşgörüyle karşılanmazlar.

İyice araştırılmamış sorularınıza ve problemlerinize haftanın yedi günü cevap vermesini istiyorsanız çok sayıda bulunan "ticari" destek tekliflerinden faydalanmanız gerekir. Bunlar bütün ortak dağıtımlar için mevcut olup bu destek ya dağıtım satıcısı tarafından ya da yan şirketlerle verilmektedir. Farklı servis satıcılarını karşılaştırın, hangisinin fiyati ve servis anlaşması size uyuyorsa seçin.
\end{section}
\begin{section}{"help" Komutu ve "--help" Seçeneği}

\begin{em}bash\end{em}'te dahili komutlar hakkındaki daha detaylı bilgi help komutuna delil olarak komutun adı verilerek öğrenilebilir:
\begin{verbatim}
$ help exit
exit: exit [n]
    Exit the shell with a status of N.
    If N is omitted, the exit status
    is that of the last command executed.
$ _
\end{verbatim}

Daha detaylı açıklama için kabuğun rehber sayfasında ve bilgi belgelerinde mevcuttur.Bu bilgi kaynakları daha sonra bu bölümde ele alınacaktır.

Bunun yerine harici komutların (programların) birçoğu --help seçeneğini destekler. Çoğu komutlar kısaca kendileriyle kullanılan parametrelerini ve sözdizmini sıralar.

Her komut --help seçeneğini desteklemeyebilir; sık sık çağrilan seçenekler -h veya -?, ya da yanlis bir seçenek veya geçersiz komut satırı belirtirseniz yardım ekrana gelecektir. Ne yazık ki genel kuralı yoktur.
\end{section}
\begin{section}{Kabuk Satırı Kılavuz}
\begin{subsection}{Genel Bakış}

Nerdeyse her komut-satırı programı yardım sayfasıyla "manual page" (ya da "man page") gelir, ayrıca ayar dosyaları ve sistem çağrıları vs. Bu metinler 
genelde yazılımla beraber kurulur. İncelemek için "man $<$isim$>$" komutu kullanılır.

\paragraph{}{
\begin {table}[H]
\caption {Kılavuz sayfasının bölümleri} \label{tab:title} 
\begin{tabular}{c l @{} l}
\hline
Bölüm &
\multicolumn{2}{c}{İçerik} \\
\hline
NAME 	&	Komutun adı ve kısa açıklama \\
SYNOPSIS &	Komutun sözdizimi açıklaması \\
DESCRIPTION &	Komutun etkisi ile ilgili açıklama \\
OPTIONS &	Mevcut seçeenekler \\
ARGUMENTS &	Mevcut deliller \\
FILES 	&	Yardımcı dosyalar \\
EXAMPLES &	Örnek komut satırları \\
SEE ALSO &	Ilgili konulara çapraz referanslar \\
DIAGNOSTICS &	Hata ve uyarı mesajları \\
COPYRIGHT & 	Komutun yazarları \\
BUGS	&	Bilinen komut sınırlamaları \\
\hline
\end{tabular}
\end {table}
}

Buradaki $<$isim$>$ açıklanmasını istediğiniz komutun yada dosyanın adıdır. Örneğin "man bash", anılan iç kabuk komutlarının listesini üretir.

Ancak, kılavuz sayfalarinin bazi dezavantajlari vardir: Bu kılavuzların çoğu sadece Inglizcedir; farklı dillere çevirilenleri vardır ama tam değil. Üstelik açiklamalar çogunlukla karışıktır. Yeni başlayanlar belgeleri anlamayabilir o yüzden her kelime çok önemlidir. Buna ilaveten, özellikle uzun belgelerin yapısı anlaşılmaz olabiliyor. Öyle olsa bile, bu belgelerin değeri göz ardı edilemez. Kağıtlarla kullanıcıyı canından bezdirmek yerine sistemle beraber kılavuz mevcuttur.

Birçok Linux dağıtımlari komut satırından çağrılabilen her komut için bir kılavuz sayfasının olması gerektiği felsefesini takip eder. Bu, görsel masaüstü ortamı ait programları KDE ve GNOME için aynı ölçüde geçerli değildir. Bunların hiç bir kılavuz sayfasının bulunmaması haricinde görsel masaüstü çevresinde bile berbat bir şekilde belgelendirilmiştir. Bu programların çoğu gönüllüler tarafından katkıda bulunması gerçegi sadece zayıf bir bahane.
\end{subsection}
\begin{subsection}{Yapı}

man'in yapısı kabaca yukarda belirttiğimiz Tablo 5.1 taslağını takip eder. Yine de her kılavuz sayfası orada belirtilen her bölümü içermeyebilir.
Özellikle de, EXAMPLES sık sık kısa kesilmiştir.

BUGS başlığı genellikle yanlış anlaşılır: burda belgelendirilen genellikle komutun aldığı yaklaşımındaki kısıtlamalardir ve siz bu kısıtlamaların
makul bir çabayla kaldırılamadığını siz bir kullanıcı olarak bilmelisiniz. Örneğin, grep komutunun belgeleri normal ifadelerin çeşitli yapılarının bulunması   
grep sürecinin çok bellek kullanmasına yol açabildiğini belirtir. Bu grep komutunun uyguladığı arama yönteminin sonucudur ve önemsiz, kolayca giderilebilen 
hata değildir.    

Man sayfaları groff adında bir program tarafından metni görüntülemek veya yazdırmak için özel bir girdi biçimi olarak yazılır. Kılavuz sayfaları /usr/share/man dizininin mann alt dizini içinde saklanır. n Tablo 5.2'de verilen bölüm numaraları içindir.

Diğer dizinlerdeki man sayfalarını MANPATH çevresel degişkenini ayarlayarak birleştirebilirsiniz. "manpath" komutu MANPATH'in nasıl ayarlanabileceği 
hakkında ipuçları barındırır.
\paragraph{}{
\begin {table}[H]
\caption {Kılavuz sayfası konuları} \label{tab:title} 
\begin{tabular}{c l @{} l}
\hline
Bölüm &
\multicolumn{2}{c}{İçerik} \\
\hline
1 	&	Kullanıcı komutları \\
2 &	Sistem çağrıları \\
3 &	C dili kütüphane işlevleri \\
4 &	Aygıt dosyaları ve sürücüleri \\
5 &	Ayar dosyaları ve dosya formatları \\
6 & Oyunlar \\
7 &	Çeşitli (örneğin groff makroları, ASCII tabloları, …) \\
8 &	Yönetici komutları \\
9 &	Çekirdek işlevleri \\
n & "Yeni" komutlar \\
\hline
\end{tabular}
\end {table}
}
\end{subsection}
\begin{subsection}{Bölümler}

Her kılavuz sayfası "kılavuzu" kapsayan "bölüme" aittir (Tablo 5.2). 1, 5 ve 8 bölümler en önemlileridir. Aramayı daraltmak için man komutu satırına bölüm numarası verebilirsiniz.Örneğin, "man 1 crontab"-crontab komutu için man sayfasını görüntülerken, "man 5 crontab"-crontab crontab dosyalarının formatlarını açıklar. man sayfalarını işaret ederken, bölüm numarasını parantez içinde belirtmek gelenekseldir; biz, crontab(1)-crontab komut kılavuzu, ve crontab(5)-dosya formatı açıklaması aradaki farkı ayırt ederiz.

-a seçeneğiyle man verilen isme göre bulunan kilavuzu gösterir; seçenek vermezsek ilk bulunan sayfayı (genellikle bölüm 1) gösterir.
\end{subsection}
\begin{subsection}{Kılavuz Sayfalarını Görüntülemek }

man sayfalarını metin terminalde görüntülemek için asıl program daha üzerinde duracağımız less ile gerçekleştirilir. Bu aşamada man sayfasında yukarı ok işareti ? ve aşağı ok işareti ? ile gezinebilirsiniz. Metnin içinde anahtar kelime karakterine basarak / ardından kelimeyi girip geri dönüş tuşuna basarak arayabilirsiniz. Her geri dönüş tuşuna bastığınızda bir sonraki bulunan kayda sıçrar (eğer varsa). Kabuğa q tusuna basarak geri dönebilirsiniz.

KDE web tarayıcısı, Konqueror kullanarak güzel biçimlendirilmiş uygun man sayfaları elde etmek mümkün. Basitçe "man:/$<$isim$>$" (hatta "\#$<$isim$>$") URL'yi tarayıcının adres satırına girin. Bu metot aynı zamanda KDE komut satırı için de geçerlidir.

\paragraph{buraya iki şekil eklenecek}{şekiller}

Amaçsızca sayısız man sayfalarını aramadan önce, konu hakkında apropos yardımıyla genel bir bilgi edinmek daha mantıklıdır. Bu komut basitçe şöyle çalıştırılır "man -k"; hem de komut satırında verilen bir anahtar kelimenin "NAME" bölümlerine ilişkin tüm man sayfalarını arayabilirsiniz. Bunun sonucunun çıktısı tüm man sayfalarını, adı veya açıklama kısmında anahtar kelimeyi de içerecek şekilde bir liste görüntüler.

Bu konuyla alakalı olan bir başka komut whatis'dir.Bu komut da tüm man sayfalarını arar ama yukarida belirttiğimiz komuttan farkı whatis aramayı anahtar kelimeye göre değilde komutun (dosya,...) adına göre yapar. Bu istenilen komut, sistem çağrıları vs. hakkında kısaca bir açıklama görüntüler. Özellikle söz konusu man sayfasının(lar) "NAME" bölümünün ikinci  kısmını verir. "whatis" ile "man -f" eşdeğerdir.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item ls komutu için kılavuz sayfasını görüntüleyin. Metin tabanlı man komutunu kullanın ve eğer mümkünse - Konqueror tarayıcısını.
 \item Sisteminizde hangi kılavuz sayfaları (en azından "NAME" bölümlerine göre) süreçlerle iş yapar.
 \item (Ileri düzey) Kuramsal bir komutun kılavuz sayfasını yazmak için metin editörü kullanın. Önceden man(7) man sayfasını okuyun. man sayfasının görünürlüğünü kontrol edin ("groff -Tascii -man $<$dosya$>$ | less" komutunu kullanarak) yazılı çıktı olarak ("groff -Tps -man $<$dosya$>$ | gv -" gibi birşey kullanın).
\end{itemize}}
\end{subsection}
\end{section}
\begin{section}{Bilgi Sayfaları}

Bazı komutlar için - genellikle karmaşık olanlar için sıradan man sayfaları yerine (yada ilave olarak) "bilgi sayfaları" mevcuttur.
Bunlar genellikle daha genis olup hiper metin prensibine göre kurulmuştur. World Wide Web'e benzer şekilde.

Bilgi sayfaları fikri GNU projesi ile birlikte ortaya çıkmıştırtir; o yüzden onlar en sik FSF (özgür yazilim vakfi)'le yayimlanan yazilimlarla gelir. Aslında "GNU sistem"de sadece bilgi belgeleri olmasi gerekiyordu; ancak GNU, FSF himayesinde geliştirilmeyen bir sürü yazılımları da kendi içine alır, ve GNU araçları çizgileri daha kesin olan sistemlerde kullanılmaktadır, FSF ise bazı durumlarda taviz vermeye başladı.

man sayfalarının dengi olan bilgi sayfaları "bilgi $<$komut$>$" komutu (bilgi programını içeren paket açıkça kurulmuş olması gerekebilir) kullanılarak görüntülenir. Ayrıca, bilgi sayfaları emacs editöründe veya KDE web tarayıcısı Konqueror'da URL'ler yardımıyla "info:/$<$command$>$" görüntülenebilir.

Bilgi sayfalarının bir avantajı, man sayfaları gibi kaynak formatında yazılmış olmalarıdır. Bilgi sayfaları PDF ve PostScript formatında yazdırılabilir veya ekranda islenebilir. groff yerine, \TeX{} dizgi programını kullanarak çıktı işlemi için hazırlanabilir.

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item ls programı için bilgi sayfasına bakın. Metin tabanlı bilgi tarayıcısı ve, varsa, Konqueror tarayıcısını deneyin.
 \item Bilgi sayfaları hiper metnin ilkel formunu kullanır. Günümüzde HTML dosyalarının World Wide Web'de olduğu gibi. Bilgi sayfaları neden HTML ile yazılmamıştır?
\end{itemize}}
\end{section}
\begin{section}{NASIL Belgeleri}

Kılavuz ile bilgi sayfaları arasındaki ortak problem şudur: Kullanıcılar kullanacakları programın adını bilmek zorundadırlar. Hatta apropos'la 
arama yapmak şans oyunu gibi birşeydir. Ayrıca, her problem tek bir komut kullanılarak çözülemez. Bu nedenle bunlar "komut odaklı" belgeler yerine
genellikle "problem odaklı" olarak adlandırılır. Nasıl Yapılır kısmı bunlara çözüm üretmek için tasarlandı.

Nasıl Belgeleri kendilerini tek bir komutla  kısıtlamayan geniş kapsamlı belgelerdir, ama sorunların çözümü için tam yaklaşımları açıklamaya çalışırlar.
Örneğin, DSL yoluyla Linux sisteminin internete nasıl bağlanacağını detaylı olarak açıklayan "DSL HOWTO" kısmı vardır, ya da Linux için astronomi yazılımını tartışan "Astronomi NASIL" vardır. Nasıl Yapılır kısımlarının birçoğu İnglizce aslını genellikle geriden takip etse de bunlar başka dillerde de mevcuttur.

Nasıl Belgeleri çoğu Linux dağıtımında yerel olarak kurulu olmasını sağlar. Bunlar dagıtıma özel dizinlerin altında bulunurlar. /usr/share/doc/howto 
SUSE dagıtımları için, /usr/share/HOWTO Debian GNU/Linux içindir. Tipik olarak düz metin veya HTML dosyaları içerir. Nasıl Yapılır'ların geçerli tüm sürümleri
ve diğer PostScript veya PDF biçimindekilerinin hepsi internet üzerinde "Linux Documentation Project" (http://www.tldp.org) bulunabilir. Ayrıca diğer
Linux belgeleri de sunar.
\end{section}
\begin{section}{Daha fazla Bilgi Kaynakları}

Neredeyse her kurulu olan yazılım için ilave belgeleri veya örnek dosyaları /usr/share/doc ya da /usr/share/doc/packages (kullandığınız dağıtıma bağlı olarak değişir) altında bulunur. Çoğu GUI uygulamaları (KDE veya GNOME paketlerindeki gibi) "help" yardım menüsü sunar. Üstelik birçok dağıtımlar uzmanlaştırılmış "help centers" yardım merkezleri sunar. Sistem üzerindeki çoğu belgelere uygun erişimi sağlar.

Linux için daha ilgi çekici sitelerden bazıları:
\paragraph{http://www.tldp.org/}{“Linux Documentation Project”, man sayfaları ve Nasıl Yapılır'dan sorumlu (diğer şeylerin yanı sıra).}
\paragraph{http://www.linux.org/}{Linux meraklıları için genel portal.}
\paragraph{http://www.linuxwiki.de/}{Linux ile ilgili her şey için serbest biçimli metin bilgi veritabanı (Almanca)}
\paragraph{http://lwn.net/}{Haftalik Linux Haberleri - her türlü Linux haberleri için belki de en iyi web sitesi. Yeni gelişmeler, ürünler, güvenlik açıkları, basındaki Linux savunuculuğu vs. ayrıca her persembe günü geçmiş haftaların araştırmalarının yer aldığı çevrimiçi dergi de bulunur. Günlük haberlere ücretsiz olarak ulaşılabilir iken haftalık yayınlamalara belli bir ücret ödenmesi gerekiyor (aylık 5\$'dan başlayan fiyatlarla). İlk çıktığı haftadan sonra o yayınları ücretsiz olarak erişilebilir hale getiriyorlar.}
\paragraph{http://freecode.com/}{Bu site yeni (genel olarak serbest) çıkan yazılım paketlerini tanıtır. Buna ek olarak ilginç projeler veya yazilim paketleri için sorguları sağlayan bir veritabanı var}
\paragraph{http://www.linux-knowledge-portal.de/}{LWN ve Freshment dahil diğer Linux sitelerinden haber başlıklarını toplarlar.}

Eğer Internette veya Usenet arşivlerinde bulmadıysanız aradığınızı sorunuza cevabı  posta listelerinde soru sorarak yada Usenet gruplarında bulabilirsiniz. Bu forumlardaki çoğu kullanıcılar daha önce cevaplanmış yada dokumantasyonda olan birşeyi sormanıza kötü tepki verebilirler. Probleminizin detaylı açıklamasını hazırlayın, log dosyalarından ilgili ayrıntıları verin çünkü karmaşık
problemleri sizde olduğu gibi uzak mesafeden çözmek zordur (karmaşık olmayan problemleri kendinizin çözebiliyor olmaniz lazım).

Haber arşivlerini http://groups.google.com/ (eskiden DejaNews) adresinde bulabilirsiniz.

Linux için ilgi çekici haberler, gruplar inglizce için comp.os.linux.* veya almanca için de.comp.os.linux.* hiyerarsilerinde bulunabilir. Birçok Unix grupları Linux konuları için uygundur; kabukla ilgili soruları kabuk programlama için ayrılan grupta sorulması gerekiyor Linux grubunda değil çünkü kabuklar genellikle Linux'a özgü birşey değildir.

Linux tabanlı posta listelerini örneğin, majordomo@vger.kernel.org adresinde bulabilirsiniz. LIST denilen listeye katılmak için önce "subscribe LIST" adresine e-posta atmanız gerekiyor. Sistemde mevcut yorumlanmış tüm posta listeleri http://vger.kernel.org/vger-lists.html'de bulabilirsiniz.

Görünüşte anlaşılmayan problemleri çözmenin yolu hata mesajının Google'da aratmaktır(ya da güvendiğiniz baska bir arama motoru).  Eğer faydalı bir sonuç alamazsanız, arama yaptığınız sorguda sadece size özel duruma bağlı kısımları kaldırın (mesela alan adları gibi).  Google'da aramanın avantajı sadece ortak web sayfalarını indekslemek değil bunun yanında posta liste arsivlerini de indeksler. O yüzden sizin gibi sorunu yaşayan bir başka birilerinin bulunması da olası bir durum.

Açık kaynak kodlu yazılımların önemli avantajlarından biri büyük miktarda dokumantasyonun olması değildir ayrıca çoğu dokumantasyonun da en az yazılımının kendisi gibi kısıtlı olmasıdır. Bu yazılım geliştiricileri ve belge yazarlar arasındaki işbirliğini kolaylaştırır ve belgelerin diğer dillere çevrilmesi daha kolaydır. Aslında, programcı olmayanlar için özgür yazılım projelerine destek verebilmeleri için bol fırsat var. Mesela güzel belgelemeler yazarak. Özgür yazılım faaliyet alanında programcılara verilen saygıyı belge yazarlarına da vermeye çalışılmalı.
\end{section}
\paragraph{Bu bölümdeki Komutlar}{
\begin{itemize}
\item apropos 	NAME bölümünde verilen anahtar kelimeyi içeren tüm kılavuz sayfalarını görüntüler
\item groff		Gelişmiş dizgi programı
\item help 		bash komutları için yardımı görüntüler
\item info 		Karakter tabanlı terminalde GNU Bilgi sayfalarını görüntüler
\item less		sayfa sayfa metinleri (kılavuz sayfaları gibi) görüntüler
\item man		Sistem kılavuz sayfalarını görüntüler
\item manpath		Sistem kılavuz sayfalarının aranacağı yolu belirler
\item whatis		Açıklamasında verilen belirli bir anahtar kelime ile kılavuz sayfaları bulur
\end{itemize}}
\paragraph{Özet}{
\begin{itemize}
\item "help $<$komut$>$" dahili bash komutlarını açıklar. Birçok harici komut --help seçeneğini destekler.
\item Çoğu program kılavuz sayfalarıyla gelirler. Bunlar man komutuyla incelenebilir. apropos verilen anahtar kelimelere göre tüm kılavuz sayfalarını arar, whatis kılavuz sayfa isimlerine bakar.
\item Bazı programlar için bilgi sayfaları kılavuz sayfalarına bir alternatiftir.
\item Nasıl Yapılır'lar problem tabanlı bir belgeleme olustururlar.
\item World Wide Web ve USENET'te Linux ile ilgili çok sayıda ilginç kaynaklar var.
\end{itemize}}

\chapter{Dosyalar: Bakım ve Besleme}
\paragraph{Amaçlar}
\begin{itemize}
 \item Linux kurallarıyla birlikte dosya ve dizin isimleriyle uğraşmaya alışmak
 \item Dosya ve dizinlerle çalışmada önemli komutları bilmek
 \item Kabuk dosya adı arama şablonlarını kullanabilmek
 \end{itemize}
 
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Kabuk kullanımı
 \item Metin editörü kullanımı
 \end{itemize}

\begin{section}{Dosya ve Yol İsimleri}
\begin{subsection}{Dosya İsimleri}

Linux gibi işletim sisteminin en önemli hizmetlerinden birisi de, veriyi sabit disk veya USB sürücüler gibi kalıcı hafızaya depolamak ve sonrasında onları kullanmaktır. Bunu insanların yapması kolaydır, benzer veriler genellikle üstünde adının yazıldığı "dosyalar" altında toplanır.

Eğer bu bile sizin için önemsiz gözüküyorsa, bu anlatılanların size hiçbir getirisi yoktur. Eskiden bazı işletim sistemleri, bir verinin bilgisini almak için disk üzerindeki track sayıları gibi ayrıntıları belirtmeyi zorunlu kılıyordu. Bu yüzden, size dosyalarla nasıl uğraşılacağını anlatmaktan önce, Linux'un dosyaları nasıl isimlendirdiğini açıklamalıyız.

Linux dosya isimlerinde, aslında bilgisayarınızın gösterebileceği her karakteri (hatta daha fazlasını) kullanmanıza olanak tanır. Ancak, karakterlerden bazılarının özel anlam içerdiğinden beri, dosya isimlerinde bu karakterleri kullanmanızı tavsiye ederiz. Yalnızca iki karakterin kullanılamaz: bölü ("/") işareti ve 0 byte (ASCII değeri 0 olan karakter). Boşluk, inceltme işareti ya da dolar işaretleri gibi karakterler serbestçe kullanılabilir, fakat komut satırında "$\backslash$" veya tırnak işaretlerinin sırası kabuk tarafından yanlış yorumlanacağından, genellikle bu kullanımdan kaçınmak gerekir.

Acemilerin kolayca tuzağa düşeceği olay ise, Linux'un dosya isimlerinde büyük/küçük harfleri ayırt edebilmesidir. Aksine Windows, dosya isimlerinde büyük/küçük harfleri gösterir, fakat aynı dosya gibi davranır, Linux ise x-dosyaları ve X-Dosyalarının iki farklı dosya adı olduğunun farkındadır.

	Limitlerin "dosya sistemine" bağlı olduğundan beri, Linux altında byte'lar halinde düzenlenen dosya adları "çok uzun" olabilir(Linux'ta  bu düzenlemeyle ilgili birçok yöntem vardır). Normal sınır 255 karakterdir— fakat 3 satırdan daha fazla uzunlukta dosya isimleri standart metin terminalinde size karmaşıklık yaratabilir.
	
	DOS ve Windows bilgisayarlardan başka bir fark da Linux, dosyanın tipini belirlemek için sonekleri kullanmaz. Bu yüzden, dosya ismindeki nokta tamamen sıradan bir karakterdir. Bir metin dosyasını mumble.txt olarak kaydetmede serbestsiniz, fakat prensip olarak sadece mumble kelimesi de  kabul edilebilir. Bu kullanım tabi ki sizin tamamen uzantı ile adlandırmanızı engellememelidir—Bununla birlikte bu kullanım dosya içeriğini tanımlamanızda kolaylık sağlar.
	
	Bazı programlar girdi dosyalarında özel uzantı kullanmayı zorunlu kılar. Örneğin C derleyicisi olan gcc, ".c" ile biten C kaynak kodu, ".s" ile biten makine dili kaynak kodu, ve ".o" ile biten ön derlenmiş nesne dosyaları isimlerini dikkate alır.
	
	Dosya isimlendirmede özgürce inceltme işareti ve diğer özel karakterleri kullanabilirsiniz. Yine de, eğer dosyalar diğer sistemlerde kullanılacaksa özel karakterleri kullanımından kaçmak en iyisidir, çünkü diğerlerinde dosyaların aynı isimle gösterileceğinin bir garantisi yoktur.
	
	Özel karakterler ayrıca sizin yerel ayarlarınıza bağlıdır, karakterlerin temsili için genel bir standartın olmayışı ASCII karakter setini(Çoğunlukla içinde İngilizce dili, rakamlar ve yaygın özel karakterlerin bulunduğu 128 karakteri) aşar. Çokça kullanılan kodlamalara örnek olarak ISO 8859-1 ve ISO 8859-15(sırasıyla ISO-Latin-1 ve ISO-Latin-9 olarak bilinir) bununla birlikte ISO 10646, gelişigüzel ve çok doğru olmayarak adına "Unicode" denilen genellikle "UTF-8" karakter seti ile kodlanır. Y kodlaması sistemde yürürlükte iken dizine baktığınız zaman X kodlamasıyla oluşturduğunuz dosyalar tamamen farklı gözükebilir. Bu konuların üzerinde çok durursanız, size tüm konu hiçbir şey gibi gelir.
	
	Bazen kendinizi yanlış karakter setiyle kodlanmış bir yığın dosya ile uğraşıyor olarak bulabilirsiniz. Çeşitli karakter setleri arasında dönüşüm yapabilen convmv programı bu konuda size yardım edebilir. (Çoğu dağıtımlarının standart kurulumunun bir parçasıdır olmadığından dolayı, muhtemelen kendiniz yüklemeniz gerekecektir.) Ancak, bunu tüm bölümü bitirdiğimiz zaman yapmanız daha uygun olur, çünkü daha normal mv'den bahsetmedik bile ...
	
Aşağıdaki tüm karakterleri dosya isimlendirmelerinde özgürce kullanabilirsiniz:
\begin{verbatim}
 ABCDEFGHIJKLMNOPQRSTUVWXYZ
 abcdefghijklmnopqrstuvwxyz
 0123456789+-._
\end{verbatim}

Ancak aşağıdaki ipuçlarına dikkat etmelisiniz:
\begin{itemize}
\item Linux ve daha eski Unix sistemlerde taşınan dosyaların isimlendirilmesinde izin verilen dosya uzunluğu en fazla 14 karakterdir. (Bu kurala uymak gerçekten önemlidir.)
\item Dosya isimleri her zaman harf veya rakamlardan biriyle başlamalıdır; diğer 4 karakterleri sadece dosya içerisinde sorunsuzca kullanabilirsiniz.
\end{itemize}

Bu kuralları anlamanın en kolayı birkaç örneği incelemektir. Uygun dosya isimlerine örnek olarak
\begin{verbatim}
X-files
foo.txt.bak
50.something
7_of_9
\end{verbatim}
verilebilir. Buna karşılık aşağıdaki kullanımlar problem oluşturabilir (muhtemelen):
\begin{verbatim}
-10F 		‘‘- ’’ ile başlıyor, özel karakter var
.profile 					Gizli dosya olacaktır
3/4-metre 				Kural dışı karakter içerir
Smörrebröd 					İnceltme işareti içerir
\end{verbatim}

Diğer bir tuhaf özellik de, dosya isimlerinin nokta(".") ile başlaması bazı yerlerde dosyanın gözden kaçmasına neden olacak, örneğin dizin içerisindeki dosyaların listelendiği zaman—bu tür dosya isimleri "gizli" gibi düşünülür. Bu özellik genellikle programların içerik ayarlarında ve dizin listelemelerde çok daha önemli dosyaların kullanıcının kafasını karıştırmamak amacıyla kullanılır.

DOS ve Windows uzmanları için: Bu sistemler dosyanın isminin bağımsızca ayarlanabildiği dosya özelliklerinin "gizli" olması ile izin verir. Linux ve Unix'te bu tarz bir destek yoktur.
\end{subsection}
\begin{subsection}{Dizinler}

Birçok kullanıcı aynı Linux sisteminde potansiyel olarak çalıştığından beri, tüm dosya isimlerinin sadece bir tane olması problem teşkil edebiliyordu. Sue kullanıcısının halihazırda aynı isimde dosya oluşturduğu için Joe kullanıcısının letter.txt isimli bir dosya oluşturamaması belirsizliğe yol açıyordu. Ayrıca Joe'nun, Sue'nun tüm dosyalarını okuyamamasını garanti eden uygun bir yol bulunması gerekiyordu.

	Bu nedenle, Linux dosyaları gruplayan "dizinler" hiyerarşik fikrine destek verir. Aynı dizinde olmaması koşuluyla, dosya isimlerinin  tüm sistemde eşsiz olması gerekmez. Özellikle bu, sistemin Joe ve Sue için farklı dizinler atayabilmesini, ve her birinin kendi dosyaları hakkında endişelenmesinin giderilmesi anlamına gelir.
	
	Ek olarak, Joe'ya Sue'nun dizinine (veya tam tersi) erişmesini yasaklayabiliriz ve dizin içerisinde kişisel dosyalar içermesi hakkında endişelenmemize gerek kalmaz.
	
	Linux'ta dizinler basit dosyalar olsa da, "sade" dosyalara erişmek için kullandığınız yöntemler ile onlara erişemeyebilirsiniz. Ancak, bu davranışı uygularken daha önce bahsettiğimiz dosya adları ve dizin isimleri kurallarını(önceki bölüme bakınız) göz önünde bulundurmanız gerekir. Sadece taksim("/") karakterinin, dizin isimlerinden,dosya isimlerini ve/veya diğer dizinleri ayrıması gerektiğini bilmeniz yeterlidir. Örnek olarak: joe/letter.txt, joe dizinindeki letter.txt dosyasıdır.
	
	Dizinler ağaç-tarzı(yaratıcı bir şekilde "dizin ağacı"  denen) yapı ile tasvir edilen diğer dizinleri içerebilir(bu "hiyerarşi" teriminden daha önce de bahsetmiştik). Bir Linux sistemi, ağacın kökleri gibi bir yapıda olan "kök dizini" denilen özel bir dizin içerir.  "/"(taksim) ile ifade edilir.
	
	İsminin aksine, kök dizininin, sistem yöneticisi anlamına gelen kök (root) ile alakası yoktur. Sadece isimleri benzerdir.
	
	Burada taksimin çift görevi vardır—hem kök dizininin adıdır, hem de dizin isimleri arasında ayraç görevi üstlenir. Bu konuya birazdan geri döneceğiz.
	
	Yaygın Linux dağıtımlarında temel yükleme, genellikle tek bir dosya hiyerarşisinde bulunan ve bunun çokça belirli düzene göre yapılandırılmış olduğu onbinlerce dosyayı içerir. Bu dosya hiyerarşisine Bölüm 10'da daha çok yer vereceğiz.
\end{subsection}
\begin{subsection}{Mutlak ve Göreceli Yol İsimleri}

Linux sistemindeki her dosya, kök dizini tarafından başlayan, ve bir dosyaya(dosyanın kendisine) ulaşıncaya kadar devam eden tüm dizinlerin adının geçtiği, ve sonunda dosyanın kendisinin bulunduğu dosya isimleriyle tasvir edilir. Örneğin, /home/joe/letter.txt ismi, joe dizini altında bulunan, sonra home dizini içerisinde konumlanan, daha sonra da evebeyn olan kök dizininin yer aldığı letter.txt dosyasına karşılık gelir. kök dizini ile başlayan isimlere "mutlak yol ismi" adı verilir—isimler dizin ve dosya isimleri barındırabilen "yol" vasıtasıyla dizin ağacı olarak tanımlandığından beri "yol isimleri" lafını kullanırız.

	Linux sisteminde her sürecin bir "mevcut dizini" (genellikle "çalışma dizini" diye adlandırılır) vardır. Dosya isimleri bu dizinin içerisinde aranır; letter.txt "letter.txt denilen mevcut dizin" için, sue/letter.txt "sue dizini içerisindeki, mevcut dizinde bulunan letter.txt" için bir kısaltmadır. Mevcut dizinden başlayan bu tarz isimlere "göreceli yol isimleri" adı verilir.
	
	Göreceli yol isimlerinin mutlak olduğunu söylemek önemsizdir: Mutlak dosya yolu bir "/" ile başlar; diğer hepsi görecelidir.
	
	Mevcut dizin evebeyn ve çocuk süreçler arasındaki "miras"'tır. Yani kabuktan yeni bir kabuk başlattığınızda(veya başka bir program), bu yeni kabuk, sizin başlatmak için kullandığınız kabuk dizini ile aynı mevcut yolu kullanır. Yeni kabuğunuzda diğer dizine cd komutunu kullanarak geçebilirsiniz, fakat eski kabuğun mevcut dizini değişmez—Eğer yeni kabuktan ayrılırsanız, eski kabuğun mevcut dizinine(değişmemiş dizine) geri dönersiniz. 
	
	Göreli yol isimlerinde(hatta mutlak olanlarda bile) 2 kullanışlı kestirme vardır: ".." isminde her zaman dizin ağacında bir bilinmeyen olan mevcut dizinin üst dizinini işaret eder—Örneğin, /home/joe, /home durumudur. Bu sıklıkla mutlak yol ismine başvurmak zorunda kalmadan, mevcut dizinden, dizin ağacı gibi gösterilen "yan dal"'a ayrılmak için kullanışlı bir yoldur. Farzedelim ki /home/joe dizininin letters ve novels isminde altdizinleri olsun. letters sizin mevcut dizininiz gibi olsun, novels dizininin içerisinde ivanhoe.txt dosyasına kaba bir şekilde mutlak yol ismi olan /home/joe/novels/ivanhoe.txt'yi kullanmaksızın ../novels/ivanhoe.txt şeklinde göreceli yol ismi belirterek referans belirtebilirsiniz.
	
	İkinci kestirme ise size açıkça bir anlam ifade etmiyor gibi gelebilir: "." ismi dizin içerisinde bulunur ve her zaman dizinin kendisini ifade eder. Neden zaten içinde bulunduğumuz dizine işaret eden böyle bir metoda ihtiyacımızın olduğunun direkt olarak bir cevabı yoktur, fakat  tabi ki bu durumların bize kattığı kullanışlı becerileri vardır. Örneğin, belki biliyorsunuzdur (ya da Bölüm 9'a bakınız) kabuğun harici komutlar için program dosyalarını ararken kullandığı çevresel dizin değişkeni olan PATH vardır. Diyelim ki bir yazılım geliştiricisisiniz, bir program çalıştırmak istiyorsunuz, haydi (a) isimli mevcut dizininiz içerisindeki dosya, ve PATH içerisinde yer almayan(Güvenlik nedenleri için her zaman iyi bir fikirdir) (b) dizniniz içerisindeki prog'u çalıştıralım, halâ kabuğunuzdayken
\begin{verbatim}
 $ ./prog
\end{verbatim} 
diyerek dosyanızı, mutlak yol ismini vermek zorunda kalmadan program olarak başlatabilirsiniz.

Linux kullanıcısı olarak sisteme girdiğinizden hemen sonra "ev dizinine" ulaşırsınız. Sistem yöneticisi sizin hesabınızı oluşturduğunda bu dizinin ismine karar verir, fakat genellikle kullanıcı isminizle aynı olur ve /home dizini altında yer alır— joe kullanıcısı için atanan /home/joe gibi.

\end{subsection}
\end{section}

\begin{section}{Dizin Komutları}
\begin{subsection}{Mevcut Dizin: cd \& Co.}

Mevcut dizini değiştirmek için cd kabuk komutunu kullanabilirsiniz: Basitçe parametre olarak arzu edilen dizin ismi verilir:
\begin{verbatim}
$ cd letters 	       letters dizinine değiştirir
$ cd .. 			   Bir üstteki dizine değiştirir
\end{verbatim}

Eğer parametresiz kullanacak olursanız ev dizininize erişirsiniz:

\begin{verbatim}
$ cd
$ pwd
/home/joe
\end{verbatim}

Mevcut dizinin mutlak yolunun çıktısını almak için pwd ("print working directory") komutunu kullanabilirsiniz.

Ayrıca mevcut dizininizi büyük olasılıkla kendi istemcinizin bir kısmı olarak görebilirsiniz. Sistem ayarlarınıza bağlı olarak

\begin{verbatim}
joe@red:~/letters> _
\end{verbatim}

gibi bir satırla karşılaşabilirsiniz. $\sim$/letters /home/joe/letters'a kısaltmadır; tilda ("$\sim$") ise mevcut kullanıcı ev dizininizi gösterir.
"cd -" komutu cd komutu ile son kullanılmış dizine tekrar geri dönmeyi sağlar. Bu kullanışlı komut iki dizin arasında peş peşe geçiş yapmayı sağlar.

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Kabukta cd dahili mi, harici mi komuttur? Neden?
 \item Kabuk kılavuz dosyasında pushd, popd, dirs komutlarını okuyunuz. Bu komutların tasvir edildiği gibi çalıştığına kendinizi ikna ediniz.
\end{itemize}}

\paragraph{}{
\begin {table}[H]
\caption {ls'deki bazı dosya gösterimleri} \label{tab:title} 
\begin{tabular}{l c c c}
\hline
Dosya Tipi & Renk & Sonek (ls -F) & Harf türü (ls -l) \\
\hline
düz metin 	&	siyah & none & - \\
çalıştırılabilir dosya 	&	yeşil & * & - \\
dizin 	&	mavi & / & d \\
link 	&	cyan & @ & l \\
\hline
\end{tabular}
\end {table}
}

\paragraph{}{
\begin {table}[H]
\caption {Bazı ls parametreleri} \label{tab:title} 
\begin{tabular}{l l}
\hline
Parametre & Sonuç \\
\hline
-a veya --all 	&	Aynı zamanda gizli dosyaları da görüntüler \\
-i veya --inode 	&	Eşsiz dosya numarasını görüntüler (inode number) \\
-l veya --format=long 	&	Ekstra bilgi görüntüler \\
-o veya --no-color 	&	Çıktı renk-kodlamasını atlar \\
-p veya -F 	&	Eklenen özel karakterle dosya türünü işaretler \\
-r veya --reverse 	&	Sıralamayı ters yapar \\
-R veya --recursive 	&	Alt dizinlerle birlikte rekürsif olarak listeler (DOS: DIR/S) \\
-S veya --sort=size 	&	Boyuta göre sıralar (büyükten küçüğe doğru) \\
-t veya --sort=time 	&	Değiştirilme tarihine göre sıralar (yeniden eskiye doğru) \\
-X veya --sort=extension 	&	Dosya uzantısına göre sıralar (“dosya türüne” göre) \\
\hline
\end{tabular}
\end {table}
}
\end{subsection}
\begin{subsection}{Dosya ve Dizinleri listeleme --ls}

Dizin ağacı etrafında yolunuzu bulmak için hangi dosya ve dizinlerin mevcut dizin içerisinde olduğunu bilmeniz gerekir. ls("list") komutu tam da bu iş için vardır.

	Parametresiz kullanımda çıktı olarak dosyaların isme göre sıralandığı bir çeşit tablo görünümlü bir yapı elde edilir. Renkli ekranların günümüzde standart haline gelmesiyle, dosya isimleri ve türlerinin farklı renklerde görüntülenmesi genelek haline geldi (Daha dosya tipleri hakkında konuşmadık; bu konuya Bölüm 10'da değineceğiz).
	
Neyse ki, günümüzde birçok dağıtım renkli kullanımı bünyesinde barındırıyor. Tablo 6.1'de en yaygın gösterimler vardır.

	Siyah-Beyaz ekranlarda—ki hala günümüzde var—, -F veya -p parametreleri önerilir. Bunlar dosya türleri ile ilişkili dosya isimlerine özel karakter eklerler. Bu karakterlerin bazılarına Tablo 6.1'de değinmiştik.
	
	Gizli dosyaları (nokta ile başlayan isimlileri) -a ("all") parametresiyle görüntüleyebilirsiniz. Bir başka kullanışlı seçenek ise -l'dir(büyük harf olarak "L", "long"(uzun) anlamı taşır, "1" rakamı değildir). Bu sadece dosya isimlerini sıralamakla kalmaz ayrıca her dosya için ek bilgi de içerir.
	
	Bazı Linux dağıtımlarında önceden ayarlanmış bazı yardımcı parametrelerin kombinasyonu olan kısaltmalar vardır; SUSE dağıtımlarında, örneğin sadece basit bir l kullanımı "ls -alF"'nin kısaltmasıdır. "ll" ve "la" ls'nin farklılaşmış bazı kısaltmalarıdır.
	
Aşağıdaki örnekte ls'nin -l'li ve -l'siz kullanımı vardır:
\begin{verbatim}
$ ls
file.txt
file2.dat
$ ls -l
-rw-r--r-- 1 joe users 4711 Oct 4 11:11 file.txt
-rw-r--r-- 1 joe users 333 Oct 2 13:21 file2.dat
\end{verbatim}

İlk durumda, bütün gizli olmayan dosyalar listelendi; ikinci durumda ise ekstra bilgi eklendi.

	Uzun formatın farklı parçalarının anlamları vardır: İlk karakter dosya türünü verir (Bölüm 10'a bakınız); sade dosyalar "-", dizinler "d" şeklinde vb.(Tablo 6.1'deki "karakter türleri").
	
	Sonraki 9 karakter erişim izinlerini gösterir. Sonraki dosyanın adedini, dosyanın sahibini(joe), ve dosyanın grubunu(users) gösterir. Byte olarak dosyanın boyutundan sonra, dosyanın içerdiği son değiştirilme bilgisini tarih ve saat olarak görebilirsiniz. Ve tabi ki dosyanın adı da görüntülenir.
	
	Kullandığınız dile bağlı olarak özellikle tarih ve saat sütunları örmeklerimizden(asgari dil ortamı "C" kullanarak oluşturduğumuz) tamamen farklı görünebilir. Bu genellikle interaktif kullanımda sorun çıkarmaz, fakat eğer kabuk betiğinizin bir bölümünde "ls -l"'nin çıktısını almaya çalışıyorsanız büyük bir sıkıntı ortaya çıkabilir. (Gelişmiş Linux kılavuzunu çalışmaktan önce, kabuk betiklerinde ön tanımlanmış dil çevreselini kullanmanızı öneririz.)
	
	Eğer dizin için ekstra bilgi görmek isterseniz(/tmp dizini gibi), "ls -l /tmp"'nin size gerçekten bir yardımı dokunmaz, çünkü ls /tmp içerisindeki tüm dosyaların verisini listeleyecektir. -d parametresi kullanarak /tmp'nin kendisinin bilgisini elde edebilirsiniz.
	
ls burada bahsedilenlerden çok daha fazlasına destek verir; önemli olanlarından bir kaçı Tablo 6.2'de gösterilmişti.

Linux Essentials ve LPI-101 gibi LPI sınavlarında, kimse sizden ls'nin tüm 57 tane parametresini bilmenizi beklemez. Ancak en önemli yarım düzine kadarını—yaklaşık Tablo 6.2. içeriğindeki kadarını— ezberlemek isteyebilirsiniz.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item /boot dizinini hangi dosyaları içerir? Alt dizinleri var mıdır? Varsa hangileridir?
 \item Dosya ismini parametre olarak alan ls ile dizin ismini parametre olarak alan ls arasındaki fark nedir?
 \item Eğer dizin adı programda geçiyorsa, dizindeki dosyaların bilgisini görüntülemektense ls'ye sadece dizinleri göstermesi için hangi parametre ile çalıştırırız? (İpucu:Belgeye bakınız.)
\end{itemize}}
\end{subsection}
\begin{subsection}{Dizin Oluşturma ve Silme: mkdir ve rmdir}

Dosyalarınızı düzenli bir şekilde tutmak istediğinizde yeni bir dizinler oluşturmak iyi bir fikirdir. Dosyalarınızı ilişkili konuya göre (Örnek olarak) bu "klasörler" altında toplayabilirsiniz. Tabi ki ileri bir yapılandırma için, ek dizinlerle çalışarak dosyalarınızı bu dizinler altında tutabilirsiniz - hevesinizi, keyfi engeller tarafında sınırlamayınız.

mkdir komutu yeni dizinler oluşturmak için yegane komuttur. Argüman olarak bir veya daha çok dizin ismi alır, aksi halde yeni dizin oluşturmak yerine sadece bir hata mesajı alırsınız. İç içe dizinleri tek adımda oluşturabilmek için -p parametresini kullanabilirsiniz, aksi halde komut, oluşturduğunuz yoldaki dizinlerin hepsini varmış gibi farzedecektir. Örneğin:
\begin{verbatim}
$ mkdir pictures/holiday
mkdir: cannot create directory `pictures/holiday': \\
No such file or directory
$ mkdir -p pictures/holiday
$ cd pictures
$ ls -F
holiday/
\end{verbatim}
\end{subsection}
\end{section}

\begin{section}{Dosya Arama Şablonları}
\begin{subsection}{Basit Arama Şablonları}

Sık sık aynı süre içerisinde birçok dosya için bir komut uygulamak isteyebilirsiniz. Örneğin, eğer "p" ile başlayıp ".c" ile biten tüm dosyaları prog1 dizininden prog2 dizinine kopyalamak istediğinizde, her dosyanın ismini açık bir şekilde yazmak oldukça sıkıcı olabilir— eğer en azından birçok dosya ile uğraşıyorsanız! Kabuk arama şablonları kullanarak bu iş çok rahat bir şekilde yapılır.

Kabuk komut satırında belirlediğiniz bir kelimeyi yıldız ile kullanarak bunu sağlayabilirsiniz. Örneğin
\begin{verbatim}
prog1/p*.c
\end{verbatim}
Kabuk bu parametreyi, dosya isimlerinin "eşleşme" parametresine göre sıralandığı liste ile mevcut olan asıl programda başlatır. "Eşleşme", asıl dosya adında, yıldızlı keyfi karakterlerin istenen uzunlukta sıralanmasına denir. Örneğin
\begin{verbatim}
prog1/p1.c
prog1/polly.c
prog1/pop-rock.c
prog1/p.c
\end{verbatim}
yukarıdaki isimler uygundur (örnekteki son ismin özelliği için kısa not — "istenen uzunluk", "sıfır uzunluğu" içerebilir!). Yıldız ile eşleştirilemeyecek bir karakter sizce ne olabilir?—taksim işareti; genellikle arama şablonundaki yıldız karakterini bulunduğunuz dizin ile sınırlamak daha iyidir.

echo ile kolay bir şekilde bu arama şablonlarını test edebilirsiniz.
\begin{verbatim}
$ echo prog1/p*.c
\end{verbatim}
komutu herhangi bir zorunluluk, kural vb. olmaksızın eşleşen dosya isimlerini çıktı olarak verir.

Eğer gerçekten tüm dosyaları belirli bir dizin ile başlayan dizin ağacında girdi olarak vermek isterseniz, bunun için yapılacak bir çok yöntem vardır. Bu konuya 6.4.4'te değineceğiz.

"*" arama şablonu "mevcut dizindeki tüm dosyaları" tanımlar—nokta ile başlayan gizli dosyalar hariç. Olası zahmetli sürprizleri engellemek için, şayet açıkça ".*" gibi anlam içeren dosyaları aramıyorsanız, arama şablonlarını dikkatlice, gizli dosyaları göz ardı ederek kullanmalısınız.

	DOS veya Windows gibi işletim sistemlerinin komut satırında yıldız kullanımı ile rastgelmiş ve "*.*" kullanarak dizindeki tüm dosyalara işaret etmiş olabilirsiniz. Linux'ta bu doğru değildir—"*.*" şablonu "nokta içeren tüm dosyalar" ile eşleşir, fakat nokta zorunlu değildir. Linux'taki karşılığı dediğimiz gibi "*"'dır.
Soru işareti arama şablonu sadece tek bir keyfi karakter ile eşleştirmek için kullanılır(yine taksim işareti hariç). Şablon
\begin{verbatim}
p?.c
\end{verbatim}
gibidir ve böylece
\begin{verbatim}
p1.c
pa.c
p-.c
p..c
\end{verbatim}
isimli dosyalarla(diğerleri arasından) eşleştirir. Unutmayın mutlaka bir karakter bulunmalıdır — yıldızda olduğu gibi "hiçbir şey" seçeneği burada geçerli değildir.

Özellikle çok önemli bir olaya dikkat etmelisiniz: Arama şablonunun genişlemesi kabuğun sorumluluğu altındadır! Çalıştırdığınız komutlar genellikle arama şablonları hakkında birşey bilmez ve ilgilenmezler de. Onlar yol isimlerini listeleyerek bakmaya başlar, fakat nereden geldikleri ile ilgilenmezler—Örneğin, onlar direkt olarak kaynağın yazılabilir olup olmadığını veya arama şablonlarının genişlemesinin sonuçlarına bakmazlar.

Bu arada, kimse arama şablonlarının sonuçlarının yol isimleri kadar yorumlanabilir olduğunu söylemez. Örneğin, eğer bir dizin içerisinde "-l" isminde dosya içeriyorsa,  "ls *"'nin o dizinde kullanılması size ilginç ve belki de sürpriz bir sonuç verecektir.(bkz: Alıştırma 6.9)

Eğer kabuk, arama şablonlarıyla eşleşen isimlerde dosyaları bulamazsa ne olur? Bu durumda söz konusu komut, arama şablonunu pas geçer; Kendi konusu ne ise onu yapar. Genellikle bu tarz arama şablonları dosya isimleri kadar yorumlanmışlardır, fakat söz konusu "dosya" ise bulunamaz ve hata mesajı bildirilir. Ancak, arama şablonları ile kullanışlı işler yapabileceğiniz birçok komut vardır—bütün bunlarla, gerçekten meydan okuyabileceksiniz, kabuğun çalıştırdığı komut, kendi genişlemesini kesmeye yeltenmez.(İpucu:tırnak işaretleri)
\end{subsection}
\begin{subsection}{Karakter Sınıfları}
Kısmen arama şablonlarında eşleştirilen karakterlerin daha hassas tanımlanması için "karakter sınıfları" önerilir: Formun bir arama şablonunda
\begin{verbatim}
prog[123].c
\end{verbatim}
köşeli parantez içindeki karakterler, içerisinde tam olarak o karakter geçen isimlerle eşleşir. Bu sebeple örnekteki şablon
\begin{verbatim}
prog1.c
prog2.c
prog3.c
\end{verbatim}
ile eşleşir, fakat bunlar ile değil

\begin{verbatim}
prog.c 		Tam olarak bir karakter gerekli
prog4.c 		4 sıralandırmada yok
proga.c 		a harfi de olmaz
prog12.c		 Tam olarak bir karakter, lütfen
\end{verbatim}
Daha kullanışlı bir gösterim de, özel aralıkları belirleyebilirsiniz.
\begin{verbatim}
prog[1-9].c
[A-Z]bracadabra.txt
\end{verbatim}
İlk satırdaki köşeli parantezdekiler tüm rakamlarla, 2. satırdaki de büyük harfle başlayanlarla eşleşir.

Yaygın karakter kodlamalı kelimelerin birleşmeyeceğini dikkate alın
\begin{verbatim}
prog[A-z].c
\end{verbatim}
gibi şablon sadece progQ.c ve progx.c, fakat ayrıca prog\_.c ile de eşleşmez.(ASCII tablosunu kontrol ediniz, örnek "man ascii" kullanarak.) Eğer "sadece büyük ve küçük harf" eşleştirmek istiyorsanız, bunu

\begin{verbatim}
prog[A-Za-z].c
\end{verbatim}
kullanabilirsiniz.
\begin{verbatim}
prog[A-Za-z].c
\end{verbatim}
şeklindeki bir yapı çift noktalı karakterleri yakalamaz, harfler gibi kuşkulu gözükse bile.

Daha fazla kolaylık sağlamak için, "bunların dışındaki tüm karakterler" gibi yorumlanan olumsuz karakter sınıfları belirleyebilirsiniz: 
\begin{verbatim}
prog[!A-Za-z].c
\end{verbatim}
gibi bir şey "g" ve "." arasında harf olmayan karakterli isimlerle eşleşir. Her zamanki gibi, bölü işareti hariç.

\end{subsection}
\begin{subsection}{Küme Parantezleri}
İfadelerdelerdeki küme parantezlerinin genişlemesi
\begin{verbatim}
{red,yellow,blue}.txt
\end{verbatim}
gibi sıklıkla kabuk arama şablonlarıyla birleşmesinde bahsedilir, öyle olsa bile bu gerçekten uzak bir ilişkidir. Kabuk bunu
\begin{verbatim}
red.txt yellow.txt blue.txt
\end{verbatim}
tarafından değiştirir.

Genellikle, komut satırındaki kelime, birçok virgülle ayrılmış küme parantezi içinde yazının parçaları, bu kelimelerin her biri, tüm küme parantezi ifadesi parçalardan biri tarafından değiştirilen yerde, küme parantezi arasındaki yazının parçaları kadar kelime ile yer değiştirir. Bu değiştirilme tamamen komut satırındaki yazı tabanlıdır ve herhangi dosyaların veya dizinlerin tamamen varoluşundan veya varolmayışından bağımsızdır— aksine arama şablonları daima yalnızca gerçekte sistemde yol isimlerinde varolan isimleri üretir.
Bir kelime için kartezyen çarpım olarak sonuçlanacak birden fazla küme parantezi ifadeniz olabilir, diğer kelimeler bütün olası kombinasyonlardır:
\begin{verbatim}
{a,b,c}{1,2,3}.dat
\end{verbatim}
ifadesi
\begin{verbatim}
a1.dat a2.dat a3.dat b1.dat b2.dat b3.dat c1.dat c2.dat c3.dat
\end{verbatim}
sonucunu üretir.

Bu kullanışlıdır, örneğin, sistematik olarak yeni dizinler oluşturmak için; işe yarar arama şablonları burada yardımcı olamaz, onlar sadece zaten varolan şeyleri bulabilir:
\begin{verbatim}
$ mkdir -p revenue/200{8,9}/q{1,2,3,4}
\end{verbatim}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Aşağıda mevcut dizindeki dosyalar listelenmiştir\begin{verbatim}
 prog.c prog1.c prog2.c progabc.c prog
p.txt p1.txt p21.txt p22.txt p22.dat
 \end{verbatim}Bu isimler hangi arama şablonuyla eşleşir? (a) prog*.c, (b) prog?.c, (c) p?*.txt, (d) p[12]*, (e) p*, (f) *.*
 \item "ls" ile "ls *" arasındaki fark nedir? (İpucu: İkisini de alt dizinler içeren bir dizinde deneyin)
 \item Aşağıdaki komut neden gösterilen çıktıyı üretir:\begin{verbatim}
$ ls
-l file1 file2 file3
$ ls *
-rw-r--r-- 1 joe users 0 Dec 19 11:24 file1
-rw-r--r-- 1 joe users 0 Dec 19 11:24 file2
-rw-r--r-- 1 joe users 0 Dec 19 11:24 file3
 \end{verbatim}
\end{itemize}}
\paragraph{}{
\begin {table}[H]
\caption {cp parametreleri} \label{tab:title} 
\begin{tabular}{c c l}
\hline
{} & Seçenek & Sonuç \\
\hline
-b & (yedek) &	Varolan hedef dosyalarının yedek kopyalarını isimleri ile tildayı ilişkilendirerek alır. \\
-f & (zorla) &	Varolan hedef dosyaları sorgu mesajı vermeden üzerine yazar. \\
-i & (etkileşimli) & Varolan hedef dosyalarının üzerine yazılıp yazılmayacağını sorar(dosya başına bir kez). \\
-p & (korumak) & Kaynak dosyanın bütün özelliklerini korumak için kopyalamaya çalışır \\
-R & (özyinelemeli) & Dizinleri tüm içerikleriyle birlikte kopyalar \\
-u & (güncelleme) & Yalnızca kaynak dosya hedef dosyadan yeni ise kopyalar(veya hedef dosya bulunmuyorsa) \\
-v & (ayrıntılı) & Ekrandaki tüm faaliyeti görüntüler \\
\hline
\end{tabular}
\end {table}
}
\end{subsection}
\end{section}

\begin{section}{Dosyalar ile ilgili işlemler}
\begin{subsection}{Kopyalama, Taşıma ve Silme — cp ve Arkadaşları}

İstediğiniz dosyaları cp("copy")("kopyala") komutu kullanarak kopyalayabilirsiniz. iki temel yaklaşım vardır:

Eğer cp'ye kaynak ve hedef dosya isimlerini(iki argüman) söylerseniz  kaynak dosyanın içeriğinin 1:1 kopyasını hedef dosyada oluşturabilirsiniz. Eğer hedef dosya zaten varsa genelde cp üzerine yazılması gerekip gerekmediğini sormaz, fakat sadece yapar—Uyarı(veya -i parametresi) bunun için vardır.

Ayrıca hedef dosya ismi yerine hedef dizin ismi verebilirsiniz. Kaynak dosya eski ismini koruyarak o dizine kopyalanmış olacaktır.

\begin{verbatim}
$ cp list list2
$ cp /etc/passwd .
$ ls -l
-rw-r--r-- 1 joe users 2500 Oct 4 11:11 list
-rw-r--r-- 1 joe users 2500 Oct 4 11:25 list2
-rw-r--r-- 1 joe users 8765 Oct 4 11:26 passwd
\end{verbatim}

Bu örnekte, ilk list dosyasının tam kopyasını list2 isminin altına oluşturduk. Sonra /etc/passwd dosyasını bulunduğumuz dizine(hedef dizin ismi olan nokta ile temsil edildi) kopyaladık. En önemli cp parametreleri Tablo 6.3'te listelenmiştir. 
Tek kaynak dosyası yerine, kaynak dosyalarının daha uzun listesine(veya kabuk genel arama şablonuna) izin veriliyor. Ancak, bu yöntemde farklı isimli dosyaları kopyalamak olanaksızdır, fakat sadece farklı dizine kopyalanabilir. DOS'ta her TXT dosyasının aynı isimde ve BAK uzantısıyla  “COPY *.TXT *.BAK” kullanarak yedek kopyalarını almak mümkün iken, Linux "cp *.txt *.bak" komutu genellikle bir hata mesajıyla sonuçlanacaktır.

Bunu anlamak için, kabuğun bu komutu nasıl çalıştırdığını kafanızda canlandırmak zorundasınız. Önce tüm genel arama şablonları için uygun dosya isimleriyle birlikte değiştirmeye çalışır, örneğin *.txt ile letter.txt ve letter.txt'yi. *.bak'ın *.txt uzantısında bağımlılığı ve mevcut dizinde*.bak için eşleşmeyen dosya isimleri sonucunda ne olur?—ama sonuç neredeyse hiç DOS kullanıcısının beklentisi olmayacak! Genellikle kabuk cp komutunda varolan bu dizin isminden(olası muhtemel) beri cp'nin görüş açısından başarısız olduğu genişletilmemiş *.bak genel arama şablonunu son argüman olarak alıp geçecektir.

cp komutu dosyanın tam kopyasını yaparken, fiziksel olarak saklama ortamı üzerinde dosya çoğaltılıyor ya da yeni, özdeş bir tanesi farklı depolama ortamında oluşturuluyor, mv("move")("taşıma") komutu dosyayı farklı bir yere taşır veya adını değiştirmeyi sağlar. Bu kesinlikle dizin içeriğine bağlı bir işlemdir, tabi dosya farklı bir dosya sistemine taşınmadıkça—örneğin sabit disk bölümünden USB diske kopyalamak gibi. Bu olayda dosyanın fiziksel olarak taşınması, dosyanın yeni yere kopyalanması ve eski olanın silinmesi gereklidir.

mv'nin söz dizimi ve kuralları cp'ninkiler ile özdeştir—yine yalnızca bir tane yerine kaynak dosyalarının listesini belirtebilirsiniz, ve bu durumda komut sizden son argüman olarak dizin adını bekler. Temel fark mv dosyalar kadar iyi bir şekilde dizinleri de yeniden isimlendirebilirsiniz.
mv'nin -b, -f, -i, -u ve -v parametreleri cp ile tanımlanmış özelliklere karşılık gelir.
\begin{verbatim}
$ mv passwd list2
$ ls -l
-rw-r--r-- 1 joe users 2500 Oct 4 11:11 list
-rw-r--r-- 1 joe users 8765 Oct 4 11:26 list2
\end{verbatim}
Bu örnekte asıl dosya olan list2 passwd dosyasının yeniden isimlendirilmesiyle değiştirilmiştir. cp gibi mv de eğer hedef dosya adı varsa onaylamak için sormaz, fakat acımasızca üstüne yazar.

Dosyaları silmek için olan komuta rm ("remove")("kaldırma") denir. dosyayı silmek için bulunduğunuz dizinde yazma yetkinizin olması gerekir. Bu nedenle hatta size ait olmayan dosyaları bile düzgün bir şekilde kaldırabildiğiniz ev dizininizde "malikane efendisi" sayılırsınız.

Dosya üzerinde yazma yetkisi, diğer deyişle, tamamen alakasız silme işleminde ilgili dosyadaki gibi, dosyanın hangi kullanıcı veya grupta olduğuna bağlıdır.
rm işini cp veya mv gibi acımasızca ele alır—onaylama olmaksızın dosya sisteminden tamamen silinen söz konusu dosyalar gibi. Özellikle dikkatli olmalısınız,  bilhassa kabuk genel arama şablonları kullandığınızda. Linux'ta dosya ismindeki nokta karakterinin DOS'ta özel bir anlamı yoktur. Bu nedenle, "rm *" komutu bulunan dizinde tüm gizli olmayan dosyaları siler. Alt dizinler zarar görmeden kalacaktır; ayrıca "rm -r *" ile onlar da silinebilir.

Sistem yöneticisi olarak, "rm -rf /" gibi bir komut ile tüm sistemi çöp yapabilirsiniz; son derece önem gereklidir!  “rm -rf foo*” yerine “rm -rf foo *” yazmak kolaydır.

rm'nin sildiği bütün dosyalarda bazı isimlilerin silinmemesi gerekiyorsa,"rm -i" biraz daha dikkatli bir şekilde işler:
\begin{verbatim}
$ rm -i lis*
rm: remove 'list'? n
rm: remove 'list2'? y
$ ls -l
-rw-r--r-- 1 joe users 2500 Oct 4 11:11 list
\end{verbatim}
Bu örnek, her dosya için, rm silinmesi gerekip gerekmediğini ("evet" için "e") ve ("hayır" için "h") olarak sorduğunu anlatır.

KDE gibi masaüstü ortamları genellikle dosya yöneticisinden geri dönüşümü olası olan dikkatsizce silinen dosyaları görüntüleyen "çöp kutusu" gösterimine destek verir. Komut satırı için benzer yazılım paketleri vardır.

Ek olarak -i ve -r parametrerin, rm cp'nin -v ve -f parametrelerinin kullanımına izin verir ve benzer sonuçlar üretir.

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Kendi ev dizininizde myservices denilen /etc/services dosyasının kopyasını oluşturun. Bu dosyayı srv.dat olarak tekrar isimlendirin ve /tmp dizinine kopyalayın(yeni adını koruyarak). Dosyanın iki kopyasını da silin.
 \item mv neden -R parametresine sahip değildir(cp'nin sahip olduğu gibi)?
 \item Farzedelim ki dizinlerinizden biri "-file" isminde bir dosya içersin(isminin başında tire karakteri bulunsun). Bu dosyayı silmek için nasıl bir yol izlersiniz?
 \item Eğer "rm *"'ye kazara kurban gitmesini istemediğiniz yerde bir dizininiz olsa \begin{verbatim}
 $ > -i
 \end{verbatim}gibi içerisinde "-i" denilen bir dosya oluşturabilirsiniz(Bölüm 8'de daha fazla detay açıklanacaktır). Eğer "rm *" komutunu çalıştırsanız ne olur? Neden?
\end{itemize}}
\end{subsection}
\begin{subsection}{Dosyaların bağlanması — ln ve ln -s}

Linux dosyalara "bağlantılar" adı verilen referanslar oluşturmaya izin verir, ve böylece aynı dosyaya birkaç isim atanabilir. Fakat bu neyi amaçlar? Dosya ve dizin isimleri için olan kısayollar, uygulamaların erişmesinde oluşturulması istenmeyen dosya silme işlemleri için güven, programcılar için kolaylık, geniş dizin ağaçları için alan tasarrufu sağlar ve birkaç sürümlerinde sadece küçük farklılıklarla mevcut olmalıdır.

ln("link")("bağlantı") komutu varolan dosyaya(ilk argüman) ek olarak, yeni bir isim(ikinci argüman) ataması yapar.
\begin{verbatim}
$ ln list list2
$ ls -l
-rw-r--r-- 2 joe users 2500 Oct 4 11:11 list
-rw-r--r-- 2 joe users 2500 Oct 4 11:11 list2
\end{verbatim}
Dizinin şimdi list2 isminde yeni bir dosya içerdiği görülür. Aslında aynı dosyaya sadece iki tane referans vardır. Bu bilgi referans sayıcısı tarafından "ls -l" çıktısının ikinci sütununda ipucu olarak verilir. Değeri 2'dir, dosyanın gerçekten 2 tane isme sahip olduğunu belirtir. İki dosya isimlerinin gerçekten aynı dosyaya referans olup olmadığını, sadece "ls -i" komutu kullanarak tespit edebilirsiniz. Bu durumda, ilk sütundaki dosya numarası, iki dosya için de özdeş olmalıdır. Dosya numaraları, ayrıca inode(indeks düğümü) numaraları da denir, dosya sisteminde dosyaları eşsiz olarak tanımlar:
\begin{verbatim}
$ ls -i
876543 list 876543 list2
\end{verbatim}
"Inode", "indirection node"'un kısaltmasıdır. Dosya numaraları, dosyaların hakkında ismi haricinde tüm bilgiyi tutar. Her dosya için kesinlikle bir tane dosya numarası vardır.

Eğer dosyalardan birinin içeriğini değiştirmek isterseniz, diğerinin içeriği de değişir, fakat aslında sadece bir tane dosya vardır(eşsiz dosya numarası 876543 olan). Biz sadece dosyaya başka bir isim verdik.

Dizinler dosya numaraları için dosya isimlerini eşlemede basit bir tablo görünümü üstlenirler. Açıkçası tabloda farklı isim içeren fakat aynı dosya numarası olan birçok girdi olabilir. İsim ve dosya numarasıyla birlikte olan dizin girdisine "bağlantı" adı verilir. İki bağlantısı bulunan dosya için, "orijinal" isme sahip olanı bulmanın imkansız olduğunu farketmelisiniz, ln komutu içerisindeki ilk parametre örnek olarak verilebilir. Sistemin bakış açısından iki isim tamamen farksızdır ve birbirine eşittir.

Bu arada, dizinlere bağlantı atamak Linux'ta geçerli değildir. Yalnızca, sistemin baktığı her dizin için  sadece "." ve ".." birer istisnadır. Dizinlerin ayrıca dosya olduğu ve kendi dosya numaralarına sahip olduklarından beri, dosya sisteminin nasıl içten bir şekilde uyguğunun izini sürebilirsiniz.(Ayrıca bkz. Alıştırma 6.19).

İki dosyadan birinin silinmesi, dosya numarası 876543 için olan isimlerin azalmasına yol açar. Referans sayıcısını 0 değerine ulaşmadan önce dosyanın içeriği aslında silinmiş olur.
\begin{verbatim}
$ rm list
$ ls -li
876543 -rw-r--r-- 1 joe users 2500 Oct 4 11:11 list2
\end{verbatim}
Dosya numaralarının sadece aynı fiziksel dosya sistemi(disk bölümü, USB sürücü, ...) içerisinde eşsiz olduğundan beri, bu tür bağlantılar sadece dosyanın bulunduğu aynı dosya sistemi üzerinde geçerlidirler.
Dosyanın içeriğinin silinmesi hakkındaki açıklama tam olarak doğru değildir: Eğer son dosya adı silinmişse, dosya artık açılamayabilir, fakat eğer bir süreç hala dosyayı kullanıyorsa, dosyanın açık bir şekilde kapanana veya sonlanmasına kadar devam edebilir. Unix sisteminde program sonlandırıldığında dosyanın yok olması geçici dosyaların işlemesi için yaygın bir deyimdir: Yazma, okuma için oluşturduğunuz dosyayı sonra hemen silebilirsiniz. Daha sonra dosyaya veriyi yazabilir ve devamında geri atlayıp başa dönerek tekrar okuyabilirsiniz.

ln'yi sadece iki dosya ismi argümanları değil ayrıca bir veya daha fazlası ile çalıştırabilirsiniz. İlk durumda, orijinal olarak aynı isimli bağlantı mevcut dizinde oluşturulacaktır(dosyanın konumlandığı yerde bi gerçekten farklı olmalı), ikinci durumda tüm isimlendirilen dosyalar son argüman olarak verilen dizinde orijinal adları "bağlanmış" olacaktır(mv gibi).

Hepsi bu kadar değil ancak: Linux sistemlerinde iki farklı tip bağlantı türü vardır. "sıkı bağ" denilen tür, ln komutu için ön tanımlı durum altında açıklanmıştır. Dosyayı teşhis etmek için daima dosya numarasını kullanır. Ek olarak, sembolik bağlantılar da vardır(ayrıca "sıkı bağlara" zıt olarak "dayanıksız bağ" adı verilir). Sembolik bağlantılar gerçekten  bağlantı ismindeki "hedef dosya"'yı içerirler, bayrak ile birlikte dosyanın sembolik link olduğunu belirtir ve erişim de hedef dosyaya yeniden yönlendirilerek yapılmalıdır.

Hard bağlantıların aksine, hedef dosya sembolik bağlantı hakkından hiçbir "şey" bilmez. Sembolik bağlantının oluşturulması veya silinmesi hiçbir şekilde hedef dosyayı etkilemez; ancak hedef dosya silindiğinde sembolik bağlantı "asılı" kalır, yani hiçbir yere referans olmaz(erişim sonucunda bir hata mesajı görüntülenir).

Sıkı bağların aksine, sembolik bağlantılar farklı fiziksel dosya sistemlerinde dosyalardaki gibi dizinlere bağlantı oluşturmaya izin verirler. Uygulamada, yol isimlerinin anlamı yoluyla bağın izinin tutulmasından beri, sembolik bağlantılar kolay olmasından dolayı sıklıkla tercih edilir.

Dosya veya dizin isimleri değiştiğinde fakat isteğe bağlı olarak geriye uyumluluk istenmesi açısından sembolik bağlantılar popülerdir. Örneğin kullanıcının posta kutuları(okunmamış elektronik posta içerir) /var/mail dizini altında depolanmalıdır. Geleneksel olarak, bu dizine /var/spool/mail denmiştir, ve birçok programın içinde bu değer doğrudan koda gömülüdür. /var/mail'e geçişi hafifletmek için, dağıtım /var/mail'e işaret eden /var/spool/mail adı altında sembolik bağlantı içermiş bir biçimde ayarlanabilir.(Sıkı bağlantıların dizinlere uygulanmasının geçerli olmadığı zamanlarda, sıkı bağlantılar kullanarak bunu yapmak imkansız olacaktır).

Sembolik bağlantı oluşturmak için, ln'ye -s parametresini vermelisiniz:
\begin{verbatim}
$ ln -s /var/log short
$ ls -l
-rw-r--r-- 1 joe users 2500 Oct 4 11:11 liste2
lrwxrwxrwx 1 joe users 14 Oct 4 11:40 short -> /var/log
$ cd short
$ pwd -P
/var/log
\end{verbatim}
"-s" parametresi ile oluşturulan "dayanıksız bağlantılar"'ın aksine, ln komutu -b önceden bahsettiğimiz -b, -f, -i, ve -v parametrelerine destek verir.
Artık ihtiyaç kalmayan sembolik bağlantıları kaldırmak için, düz dosyaları siler gibi kullanılan rm ile silinebilir. Bu işlem bağlantının hedefinden ziyade bağlantıya etki eder.
\begin{verbatim}
$ cd
$ rm short
$ ls
liste2
\end{verbatim}

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Kendi ev dizininizde, keyfi içerikli bir dosya oluşturun(örneğin “echo Hello >~/hello” veya bir metin editörü kullanarak). link denilen dosyaya bir sıkı bağlantı oluşturun. Dosyanın iki tane isme sahip olduğundan emin olun. Dosyayı metin editörüyle değiştirmeye çalışın. Ne oluşur?
 \item Geçenki alıştırmadaki dosyaya ~/symlink denilen bir bağlantı oluşturun. Sembolik bağlantının çalıştırılması yardımıyla dosyaya erişimin yapılıp yapılmadığını kontrol edin. Eğer sembolik bağlantının işaret ettiği dosyayı silerseniz ne olur?
 \item Hangi dizinin .. bağlantısı "/" dizinine işaret eder?
 \item Aşağıdaki komutu ve çıktısına göz atınız:\begin{verbatim}
$ ls -ai /
2 . 330211 etc 1 proc 4303 var
2 .. 2 home 65153 root
4833 bin 244322 lib 313777 sbin
228033 boot 460935 mnt 244321 tmp
330625 dev 460940 opt 390938 usr 
 \end{verbatim} Açıkça / ve /home dizinleri aynı dosya numarasına sahip olduğu görülüyor. Hani iki dizin açıkça aynı dizinde bulunamazdı?—bu olguyu açıklayabilir misiniz?
 \item Dizinlere sıkı bağlantı yapılmasının geçerli olmadığına önceden değinmiştik. Bunun nedeni nedir?
 \item “ls -l ~”'nin çıktısında, ~'nin altdizininin alt dizinler içermediğini nasıl söyleyebilirsiniz?
 \item (Zeka oyunu/araştırma alıştırması:) Diskte sembolik bağlantı veya sıkı bağlantı için ne gereklidir? Neden?
\end{itemize}}
\end{subsection}
\begin{subsection}{Dosya İçeriğinin Görüntülenmesi—more ve less}

Metin dosyalarının ekranda kullanışlı ve olanaklı olarak görüntülenmesinde, uzun dökümanları sayfa sayfa görmenizi sağlayan more komutu çok yardımcı bir araçtır. Çıktı, bir ekrandan sonra ve "--More--"'un son satırda(zaten görünen dosyanın yüzdesi tarafından tespit edilir) görüntülenmesinden sonra durur. Çıktı bir tuşa bastıktan sonra devam eder. Çeşitli tuşların anlamları Tablo 6.4'te gösterilmiştir.

more ayrıca bazı parametreleri alır. -s("squeeze")("sıkıştırma") ile, boş satırların bulunduğu alanlar sadece bir tanesi kalacak şekilde sıkıştırılır, -l parametresi sayfa çıktısını yoksayar(genellikle "\^L" olarak tanımlanır) aksi halde çıktıyı durdurur. -n$<$number$>$ $<$sayı$>$ parametresi ekrandaki gösterilen satır sayılarını ayarlar, aksi halde more terminal tanımlamasına referans oluşturan TERM'den sayıyı alır.

more'un çıktısında hala çıktının başlangıcına doğru geri gitmenin genel olarak imkansız olması gibi can sıkan sınırlamalar vardır. Bu sebeple, gelişmiş sürümü olan less(hafif bir kelime oyunu var—"less is more"("less daha fazla") olarak düşünün) daha fazla [böyle!] günümüzde çoklukla görülür. less her zamanki gibi yön tuşlarıyla metin çevresinde dolaşmanıza imkan tanır, arama alışkanlıkları geliştirilmiştir ve metininin başına/sonuna gitmeye izin verir. En yaygın kullanılan klavye komutları Tablo 6.5'te özetlenmiştir.

Bölüm 5'te bahsettiğimiz gibi, less genellikle man aracılığıyla kılavuz sayfalarını görüntüleyen bir program gibi hizmet eder. Böylece kılavuz sayfalarını incelerken tüm komutlar mevcuttur.
\end{subsection}
\begin{subsection}{Dosya arama - find}

"Burada foobar dosyası olmalı ... fakat nereye koymuştum?" şeklinde kim böyle bir hisse kapılmadı ki? Tabi ki sıkıcı bir şekilde tüm dizinlerinizi elinizle gezebilirsiniz. Fakat eğer bir şeyi kullanışlı kılmak için yardım etmezse Linux, Linux olmaz.

find komutu dizin ağacında özyinelemeli bir şekilde verilen kriterlere göre eşleşen dosyaları arar. "Özyinelemeli" alt dizinlerin, alt dizinleri şeklinde göz önünde bulundurarak devam eden anlamı içerir. find'ın çıktısı eşleşen dosyaların sonrasında diğer programlara aktarılabilecek olan yol isimlerini içerir. Sonraki örnek komut yapısını tanımlar:

\paragraph{tablo eklenecek}{}

\begin{verbatim}
$ find . -user joe -print
./list
\end{verbatim}
Bu komut mevcut dizinde tüm alt dizinlerin dahilinde joe kullanıcısına ait olan dosyaları arar. -print komutu terminalde sonucu görüntüler(bizim örneğimizde tek dosya). Kolaylık için, eğer eşleşen dosyalarla ne yapacağınızı belirlemediyseniz, -print varsayılan olacaktır.

find kendi işini yaparken birkaç argümana ihtiyacı olduğunu göz önünde bulundurun.

Başlangıç Dizini	Başlangıç dizini özenle seçilmelidir. Eğer kök dizinini seçerseniz, gerekli dosya(lar)—eğer varsa—kesinlikle bulunacaktır, fakat arama uzun zaman alır. Tabi ki sadece bu dosyaları uygun ayrıcalıklı yerlerde ararsınız.
Başlangıç dizini için tam yol adı vermek çıktıdaki dosya isimlerinin mutlak olmasına neden olur, başlangıç dizini için göreceli yol adları doğrultusunda göreli yol adları üretir. Tek başlangıç dizini yerine, dönüşte aranacak dizinlerin listesini belirleyebilirsiniz.

Bu parametreler dosyalar üzerinde detaylı bir şekilde gereksinimleri tanımlar. Tablo 6.6'da en önemli denemeler gösterilmiştir. find belgeleri çok daha fazlasını açıklar.

\paragraph{}{
\begin {table}[H]
\caption {find için deneme durumları} \label{tab:title} 
\begin{tabular}{c l}
\hline
Deneme & Açıklama \\
\hline
-name & Dosya adı örneğini belirler. Tüm kabuk arama şablonu karakterleri geçerlidir. -iname parametresi büyük/küçük harf farklılıklarını yoksayar. \\
-type & Dosya türünü belirler (bkz. Bölüm 10.2). İçerdikleri:\\
 & b blok aygıt dosyası\\
 & c karakter aygıt dosyası\\
 & d dizin\\
 & f düz dosya\\
 & l sembolik bağlantı\\
 & p FIFO (adlandırılmış yöneltme)\\
 & s Unix alan soketi\\
-user & Kullanıcıya ait olan dosyayı belirler. Kullanıcı adları, sayısal kullanıcı kimlikleri gibi verilebilir.\\
-group & Gruba ait olan dosyayı belirler. -user gibi grup adları, sayısal grup kimlikleri gibi verilebilir.\\
-size & Ayrıntılı dosya boyutunu belirler. Sade sayılar 512-byte'lık bloklar halinde ifade edilir; byte'lar veya kibibayt'lar sırasıyla c veya k ekleyerek verilebilir. Önce gelen artı veya eksi işareti alt veya üst sınırı gösterir; Örneğin, -size +10k, 10Kib'den büyük olan dosyalarla eşleşir.\\
-atime & (ing. access) son erişim(okuma/yazma) tarihi bazında dosyaları aramaya imkan tanır.  Bu ve sonraki iki deneme gün olarak argüman alır; …time yerine …min 1 dakika hassasiyetle işler.\\
-mtime & (ing. modification) değiştirme zamanına göre seçer.\\
-ctime & (ing. change) son dosya numarası zamanının değiştirilmesine göre seçer(including içeriğe erişim, dosya yetki değişimi, yeniden isimlendirme, vb.)\\
-perm & Dosyanın eşleşmesi gerektiği yetkiler kümesini belirler. Yetkiler sekizlik sayı sisteminde verilir. (bkz. chmod komutu)
Özellikle bir izin aramak için, sekizlik sayı eksi işaretiyle birlikte önce gelmek zorundadır, örneğin, -perm -20 komutu diğer izinlere bakılmaksızın, grup yazma izni olan tüm dosyalarla eşleşir.\\
-links & Uygun dosyaların eşleştiği referans sayı değerini belirler.\\
-inum & Verilen dosya numarasıyla eşleşen bağlantıları bulur.\\
\hline
\end{tabular}
\end {table}
}
\paragraph{}{
\begin {table}[H]
\caption {find için mantıksal operatörler} \label{tab:title} 
\begin{tabular}{l c l}
\hline
Parametre & Operatör & Anlam\\
\hline
! & Değil & Sonraki deneme eşleşmemelidir\\
-a & Ve & -a'nın sağ ve sol yanındaki iki deneme de eşleşmelidir\\
-o & Veya & -o'nun sağ veya sol yanındaki iki denemeden en azından biri eşleşmelidir\\
\hline
\end{tabular}
\end {table}
}

Eğer çoklu denemeler aynı zamanda verilirse, eşleşecek dosyaların hepsi dolaylı olarak birlikte mantıksal VE işlemine uğrarlar. find ek mantıksal operatörlere destek verir(Tablo 6.7'ye bakınız).

Mantıksal operatörleri denerken hatalardan kaçmanın yolu, denemelerin parantezlerle kapatılmasıdır. Parantezler tabi ki kabuktan kaçırılmış olmalıdır:

\begin{verbatim}
$ find . \( -type d -o -name "A*" \) -print
./.
./..
./bilder
./Attic
$ _
\end{verbatim}

Bu örnek dizine işaretçi olan veya "A" ile başlayan, ya da her ikisi koşulundaki dosyaların isimlerini listeler.

\paragraph{Eylemler} Önceden bahsettiğimiz gibi, arama sonuçları ekranda -print parametresiyle görüntülenebilir. Buna ek olarak, -exec ve -ok adında dosya isimleri içeren komutları çalıştıran 2 parametre vardır. -ok ve -exec arasındaki tek fark, -ok gerçekten komutu çalıştırmadan önce bilgi için kullanıcıya sorar; -exec ile üstü kapalı bir şekilde bu işlemin yapıldığı varsayılır. Biz -exec'i ele alırken kendimizi kısıtlayacağız.

-exec parametresini yöneten bazı genel kurallar şunlardır:
\begin{itemize}
\item -exec'in devamındaki komut noktalı virgül(";") ile sonlandırılmak zorundadır. Birçok kabuklarda noktalı virgülün özel karakter olduğundan beri, find'ı görünebilir yapmak için noktalı virgül kaçırılmış olmak zorundadır (örneğin "\\" veya yorumların kullanımı gibi).
\item Komutun içerisindeki iki süslü parantez ("\{\}") bulunan isimle, dosya ismini yer değiştirir. Bu dosya adlarında boşluk sorunlarını önlemek için tırnak içinde parantez içine almak en iyisidir.
\end{itemize}

Örneğin;
\begin{verbatim}
$find . -user joe -exec ls -l '{}' \;
-rw-r--r-- 1 joe users 4711 Oct 4 11:11 file.txt
$ _
\end{verbatim}

Bu örnek mevcut dizin(ve altında) içerisindeki tüm dosyaların her biri için için test kullanıcısına ait olanları arar ve "ls -l" komutunu çalıştırır. Aşağıdaki daha mantıklı olacaktır:

\begin{verbatim}
$ find . -atime +13 -exec rm -i '{}' \; 
\end{verbatim}

Bu etkileşimli olarak mevcut dizin(ve altındaki) son 2 haftadır erişilmeyen dosyaları siler.

Bazen - yukarıdaki son örnekteki gibi— bulunan her bir dosya adı için -exec kullanarak yeni bir süreç başlatmak çok verimsiz olur. Bu durumda komutu çalıştırmadan önce olası bütün dosya isimlerini toplayan xargs komutu kullanışlı olacaktır.
\begin{verbatim}
$ find . -atime +13 | xargs -r rm -i
\end{verbatim}
xargs standart girdiyi,  maksimum(yapılandırılabilir) karakter veya satıra kadar okur ve bu materyali belirlenen komut için argüman olarak kullanır(bu örnekte rm). Girdide, argümanlar boşluk karakterleri(tırnaklar veya "\" kullanarak kaçırılabilir) veya yeni satırlar tarafından ayrılmıştır. Komut girişi bitirmeye gerektiği kadar çağrılır.— -r parametresi sadece eğer find gerçekten dosya ismi gönderdiyse çağrılmasını sağlar; aksi halinde en azından bir kez çalıştırılmış olacakatır.

Garip dosya isimleri find/xargs kompinasyonunun kullanımında sorun oluşturabilir, örneğin ayrıcılar olarak sorun olabilen boşluklar veya, gerçekten de, yeni satırlar içerenler. Sihirli çözüm find'da "-print"'in yaptığı gibi dosya isimlerini çıktıya veren, fakat yeni satırlar yerine null byte'lar kullanarak ayıran "-print0" parametresinin kullanımıyla sağlanır. Null byte'ın yol isimlerinde geçerli karakter olmadığından beri, karışıklık artık mümkün değildir. xargs bu tarz girdideki gibi "-0" parametresi kullanarak çağırılmak zorundadır:
\begin{verbatim}
$ find . -atime +13 -print0 | xargs -0r rm -i
\end{verbatim}

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Sisteminizdeki 1MB'dan daha büyük olan tüm dosyaları bulun ve isimlerini çıktıya verin.
 \item Bir olağandışı isime sahip dosyayı find kullanarak nasıl silebilirsiniz(örneğin eski kabukların başa çıkamadığı görünmez kontrol karakterleri veya umlautlar)?
 \item (Kitap aracılığıyla ikinci kez.) Nasıl kendinize ait bir kez çıktığınızda silinen dosyaları koruma altına alırsınız?
\end{itemize}}
\end{subsection}
\begin{subsection}{Çabukça Dosyaları Bulma - locate ve slocate}

find komutu birçok farklı kritere bağlı olarak dosyaları arar fakat başlangıç dizini altındaki dizin ağacını tamamen gezmek zorundadır. Ağaç boyutuna göre, bu dikkate değer bir zaman alır. Tipik bir uygulamada—belirli isimlerle aranan dosyalar—hızlandırılmış bir yöntem vardır.

locate komutu kabuk genel arama şablonunda eşleşen isimlere ait düm dosyaları listeler. En sıradan durumda, bu basit karakterlerin dizisidir:
\begin{verbatim}
$ locate letter.txt
/home/joe/Letters/letter.txt
/home/joe/Letters/grannyletter.txt
/home/joe/Letters/grannyletter.txt~
\end{verbatim}

Bununla birlikte oldukça önemli bir faydası olan locate(LPIC1 müfredatının parçasında bu olgu vurgulanmıştır), tüm Linux dağıtımlarında varsayılan yüklemenin bir parçası değildir. Örneğin, eğer bir SUSE dağıtımı kullanıyorsanız, locate kullanabilmek için önce açıkça findutils-locate paketini kurmanız gerekir.

"*", "?", ve "[...]" karakterleri kabukta yaptıkları gibi locate'te de aynı görevi üstlenirler. Fakat genel arama karakterleri olmayan sorgu herhangi bir yerdeki şablonun içerdiği tüm dosya isimleri ile yerleşirken, genel arama karakterleriyle yapılan sorgu sadece tamamen—baştan sona— şablonun tasvir ettiği isimleri geri döndürür. Bu nedenle locate için olan şablon sorguları genellikle "*" ile başlar:
\begin{verbatim}
$ locate "*/letter.t*"
/home/joe/Letters/letter.txt
/home/joe/Letters/letter.tab
\end{verbatim}

Kabuk genel arama karakterleri içeren locate sorgularının açılmaya çalışılmasından kabuğu korumak için etrafına tırnaklar koyduğunuzdan emin olun.
Bölü ("/") özel olarak işlenmez:
\begin{verbatim}
$ locate Letters/granny
/home/joe/Letters/grannyletter.txt
/home/joe/Letters/grannyletter.txt~
\end{verbatim}

locate çok hızlıdır çünkü dosya sistem ağacında gezinmez, fakat önceden ubdatedb programı kullanılarak oluşturulması gereken dosya isimleri "veritabanı"'nı kontrol eder. Bu son veritabanı güncellemesinden beri sisteme eklenen dosyaların locate tarafından yakalanamayacağı anlamına gelir, ve aksi bir şekilde bu zamanda silinmiş olan dosyaların isimlerini de çıktıya verebilir.

locate'in varolan dosyalarını sadece "-e" parametresi kullanarak alabillirsiniz, fakat bu yöntem locate'in hız avantajını reddeder.

updatedb program locate için veritabanı oluşturur. Bunun önemli büyüklükte zaman aldığından beri, sistem yöneticiniz genellikle bunu sistem çok iş yapmayacağı zaman(tahminen gece geç saatte) çalıştırılacak şekilde ayarlar.
Bunun için gerekli olan cron hizmeti Advanced Linux'ta detaylarıyla anlatılacaktır. Şimdi birçok Linux dağıtımları ubdatedb'nin aralıklarla sık sık sık çalıştırılmasına neden olurlar.

Sistem yöneticisi olarak, veritabanı kurarken dikkate alınması gereken dosyaları updatedb 'ye söyleyebilirsiniz. Dağıtımınıza bağlı olarak neler olur detaylıca açıklayalım: updatedb kendi kendine konfigürasyon dosyasını okuyamaz, fakat ayarları komut satırından ve (kısmen) çevresel değişkenlerden alır. Buna rağmen, birçok dağıtım genellikle ilgili olan ortam değişkenlerinin bulunduğu /etc/updatedb.conf veya /etc/sysconfig/locate gibi dosyaları okuyan kabuk betiğinden updatedb'yi çağırır.

	Örneğin /etc/cron.daily gibi bir dosya bulabilirsiniz(detaylar, dağıtımınıza bağlı olarak değişiklik gösterebilir).
	
	Örnek olarak updatedb'nin belirli dizinlerdeki aramalarına ve bu arama işleminde diğer dosyaları atmalasona sebep olabilirsiniz; program ayrıca sadece bir bilgisayarın veritabanı oluşturnası gerektiği gibi, birçok bilgisayar  tarafından kullanılan ve onların kendi kök dizinlerindeki veritabanlarında bulunan "ağ dosya sistemi"'ni belirlemenize imkan tanıyor.
	
	Önemli bir yapılandırma ayarı da kullanıcı kimliğiyle updatedb'nin çalıştırılmasıdır. Temelde iki olasılık vardır:
	\begin{itemize}
	\item updatedb root gibi çalışır ve böylece veritabanındaki her dosyaya giriş yapabilir. Bu ayrıca kullanıcıların birbirlerininkine erişemediği dizinlerdeki dosya isimlerinin de görüntülenmesini sağlar, örneğin, diğer kullanıcıların ev dizinleri.
	\item updatedb "hiçkimse" kullanıcıları gibi sınırlı ayrıcalıklarla çalışır. Bu durumda, sadece "hiçkimse" kullanıcısı tarafından okunabilen dizinlerdeki isimler görüntülenir. 
	\end{itemize}
	
slocate programı —alışılmış locate'e alternatif olarak— bu problemi dosyanın sahibi, grubu ve  izinlerinin ve buna ek olarak dosyanın isminin de veritabanında bulunması sayesinde atlatır. Sadece slocate'i hangi kullanıcı çalıştırıyorsa o dosya ismini çıktıya verir, adeta söz konusu dosyaya erişmek gibi. slocate updatedb programıyla birlikte gelir, fakat bu sadece slocate için tahsis edilen bir isimdir.

Birçok durumda, slocate de ayrıca locate komutu gibi çalıştırılabilir.

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item README çok yaygın bir dosya ismidir. Sisteminizde README denilen tüm dosyaların mutlak yol isimlerini bulunuz.
 \item Kendi ev dizininizde yeni bir dosya oluşturun ve locate çağırıldığında bu dosyanın listelenmeyeceği konusunda kendinizi ikna edin(uygun egzotik bir dosya adı kullandığınızdan emin olun. updatedb'i çalıştırın(büyük olasılıkla yönetici yetkileri kullanarak). locate sonradan sizin dosyanızı bulabildi mi? Dosyayı silin ve bu adımları tekrarlayın.
 \item Kendinizi slocate'in /etc/shadow gibi dosyaları normal kullanıcı olarak çalıştırılıp arama yaptığına ikna edin.
\end{itemize}}

\paragraph{Bu Bölümdeki Komutlar}{}
\paragraph{cd}{Kabuğun mevcut çalışma dizinini değiştirir}
\paragraph{convmv}{	Karakter kodlamaları arasında dosya isimlerini dönüştürür}
\paragraph{cp}{	Dosyaları kopyalar}
\paragraph{find}{	Verilen belirli kriterler ile eşleşen dosyaları arar}
\paragraph{less}{	Metinleri(kılavız sayfaları gibi) sayfalar halinde görüntüler}
\paragraph{ln}{	"sıkı" veya sembolik bağlantıları oluşturur.}
\paragraph{locate}{	Dosya ismi veritabanında verilen isme göre dosyaları bulur}
\paragraph{ls}{	Dosya bilgisi veya dizin içeriklerini görüntüler}
\paragraph{mkdir}{	Yeni dizinler oluşturur}
\paragraph{more}{	Metin verilerini sayfalar halinde görüntüler}
\paragraph{mv}{	Dosyaların ismini değiştirir veya istenilen dizinlere taşır}
\paragraph{pwd}{	Mevcut çalışma dizininin adını görüntüler}
\paragraph{rmv	Dosyaları veya dizinleri siler}
\paragraph{rmdir}{	Boş dizinleri siler}
\paragraph{slocate}{	Dosya ismi veritabanında verilen isme göre hesaptaki dosya izinlerini alarak dosya arar}
\paragraph{updatedb}{	locate için dosya ismi veritabanı oluşturur}
\paragraph{xargs}{	Standart girdiden komut satırlarını oluşturur.}

\paragraph{Özet}{
\begin{itemize}
 \item Dosya isimleri neredeyse tüm olası karakterleri içerebilir. Ancak taşınabilirlik için,  harfler, rakamlar ve bazı özel karakterler kullanmaya kendinizi alıştırmalısınız.
 \item Linux dosya isimlerinde büyük/küçük harfleri ayırt eder.
 \item Mutlak yol isimleri her zaman bölü işareti ile başlamalı ve söz konusu olan dosya veya dizin, kökten başlayarak dizin ağacıyla birlikte verilmelidir. Göreceli yol isimleri "mevcut dizin"'den başlar.
 \item cd komutu kullanarak kabuğun mevcut dizinini değiştirebilirsiniz. Ve ismini pwd kullanarak görüntüleyebilirsiniz.
 \item ls dosya ve dizinler hakkında bilgileri görüntüler.
 \item mkdir ve rmdir kullanarak dizin oluşturabilir veya silebilirsiniz.
 \item cp, mv ve rm komutları dosya ve dizinleri kopyalar, taşır ve siler.
 \item ln komutu "sıkı" ve "sembolik" bağlantılar oluşturmanıza olanak tanır.
 \item more ve less terminal çıktısında dosyaları(ve komut çıktısını) sayfalar halinde görüntülemeye yarar.
 \item find belirli kriterlere göre eşleşen dosya ve dizinleri arar.
\end{itemize}}
\end{subsection}
\end{section}

\chapter{Düzenli İfadeler}

\paragraph{Amaçlar}
\begin{itemize}
 \item Basit ve gelişmiş düzenli ifadeleri formüle edebilmek ve anlamak
 \item grep programı ve egrep, fgrep varyasyonlarını öğrenmek
 \end{itemize}
 
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Linux, kabuk ve komutların temel bilgisine sahip olmak(önceki bölümlerden)
 \item Dosya ve dizinleri yönetmek (bölüm 6 )
 \item Metin editörünü kullanmak (bölüm 3)
 \end{itemize}

\begin{section}{Düzenli ifadeler: Temeller}

Çoğu linux komutları metin işleme için kullanılır-tekrar tekrar gözüken “buna benzer bütün satırlara xyz yap(do xyz)” biçimindeki şablonlar kullanılır. Çok kullanılan dosya satırları ve metinlerin bitlerini tanımlamak için çok güçlü bir araç,”düzenli ifade” 
\footnote{1.	Bu bilgisayar bilimlerinden bir terimdir ve harflerin kümesinden seçilen harflerin birleşmesinden sonuçlanana stringlerin küme davranışlarının bir metodunu tanımlar ve onların sınırsız tekrarını gösterir. Rutin olarak düzenli ifadeleri tanımak programlama dili derleyicileri gibi çoğu program bloklarını orta seviyede inşa etmektir.düzenli ifadeler Unix’in önceki versiyonlarında gözükür. Unix’in önceki geliştiricileri bilgisayar bilimleri tabanına sahipti böylece bu fikir onlara dahada tanıdık gelmektedir.}  olarak adlandırılır. İlk bakışta düzenli ifadeler şablonları araştıran kabuğun dosya ismine benzer görünür (bölüm 6.3), fakat onlar farklı çalışır vedaha çok olanak sağlar. 

Düzenli ifadeler, kendileri düzenli ifadeler olarak düşünülen ilkel ifadelerden özyinelemeli olarak yapılır. En basit düzenli ifadeler harfler, rakamlar ve genel karakter kümesinden karakterlerdir. Örneğin ”a”, “a” karakteriyle eşleşen düzenli ifadedir. “abc” düzenli ifadesi, “abc” stringiyle  eşleşir. Karakter sınıflar kabuk arama şablonlarına benzer anlamda tanımlanmış olabilir. Bu yüzden “[a-e]” düzenli ifadeleri, a’dan e’ye herhangi bir karakterle eşleşir ve “a[xy]b” düzenli ifadesi “axb” veya “ayb” ile eşleşir. Kabukta olduğu gibi aralıklar birleştirilmiştir. “[A-Za-z]” düzenli ifadesi tüm büyük ve küçük harflerle eşleşir ama bir aralığın tanımlanması değişik şekillerdede yapılabilir:” [\^abc]” düzenli ifadesi  “a”,”b” ve “c” dışındaki tüm karakterlerle eşleşir (kabukta “[!abc]” ile gösterilir). nokta “.” Kabuk arama şablonu içinde soru işaretine karşılık gelir, sadece 1 karakterle eşleşecektir. Tek bir istisna “\textbackslash n” karakteridir. Bu yüzden “a.c”, “abc”, “a/c” gibi ifadelerle eşleşir ama birden çok satır yapısıyla eşleşmez.
\begin{verbatim}
a
c
\end{verbatim}

Çoğu program satır satır işlendiğinden  ve çoklu satır yapılarını işletmek daha zor olacağından çoklu satır yapısına yer verilmez. (bazen bunu yapmanın güzel olmayacağını söylemiyoruz.)

Kabuk arama şablonlarının her zaman bir dosya isminin başından başlayarak  eşlemesi gerekiyorken program içerisinde seçili satırlara dayalı programlarda düzenli ifadeler üzerinde genellikle sondan başlanır. Burada düzenli ifade satırda herhangibir yerde eşleşmesi gerekir.  Siz bunu ayırabilirsiniz ancak bir şapka karakteri ile başlayan düzenli ifadeler yalnızca satır başında eşleşme yapar ve dolar (“\$”) işaretiyle biten bir ifade sadece satır sonunda eşleşme yapar. Her bir satırın sonundaki alt satır karakteri yoksayılır. Böylece “xyz” ile biten tüm satırları seçmek için “xyz\textbackslash n\$” yazmak zorunda kalmak yerine “xyz\$” kullanabilirsiniz.

Daha ciddi konuşursak “$ ^\wedge $” ve “\$” işareti satırın başlangıcındaki görünmez kavramsal karakterlerle eşleşir ve satırın sonunda yeni satır karakterinin hemen solundaki görünmez karakterle eşleşir. 

Son olarak, “*”ratgelel tekrar edilmiş önce gelen tüm düzenli ifadeleri göstermek için kullanabilirsiniz(tamamını içermeyen). Yıldızın kendisi giriş olarak herhangibir karakteri tutmaz ama sadece önceki ifadeyi değiştirir. Sonuç olarak kabuk arama şablonu “a*.txt”, “$ ^\wedge $a.*\textbackslash \textbackslash.txt ” düzenli ifadesine karşılık gelir (burada düzenli ifadenin başlangıcında ve girdi satırının sonunda “anchoring” olduğunu ve bitişik noktanın herhangibir karakterle eşleştiğini hatırlayın.) tekrar birleşmenin üzerinde önceliğe sahiptir;” ab*” bir “a ”nın peşinden gelen bir veya daha fazla “b”yi ifade eder (hiç olmayan yoktur), ”ab”nin birden fazla sayıda tekrarı olmaz.

\begin{subsection}{Düzenli İfadeler: Ekstralar}

En iyi gerçekleştirimler, şuan Tcl , Perl, veya Python benzeri modern betik dilleri içinde bulunur. Bu dillerin gerçekleştirimleri orjinal bilgisayar bilimleri içinde düzenli ifadelerin gücünü şimdiye kadar aşmıştır. 

Bazı yaygın uzantılar:

\paragraph{Kelime ayıraçları}{ “\textbackslash $<$” bir harften önce gelen harf olmayan yer eyerleşen kelimenin başlangıcında karşılaşılır. Benzer olarak, “\textbackslash$>$”  non-terminal tarafından takip edilen terminalin olduğu yerdeki kelimenin sonunda karşılaşılır.}
\paragraph{Gruplama:parantezler}{ “((...))” düzenli ifadelerin birleşiminin tekrarına izin verir. “a(bc)*” ifadesi “a”dan sonra “bc”nin bir veya daha fazla tekrarını temsil eder.}
\paragraph{Alternatif} {Dikey çubukla (“$\vert$”) birden çok düzenli ifade arasından seçim yapılabilir. “hava(alanı$\vert$limanı$\vert$sahası)” ifadesi, “havalimanı”, “havasahası” ve “havaalanı” nı temsil edebilir. Fakat tek başına “hava” olmaz.}
\paragraph{Seçimli ifadeler} {soru işareti (“?”) düzenli ifadelerin seçimli olmasını sağlar. Ya bir kez gelir ya da hiç olmaz.	“uçak (savar)?” ifadesi ya “uçak” ya da “uçaksavar”ı temsil eder.}
\paragraph{En az bir tekrar}{  (“+”) işareti (“*”) operatörüne en az bir kez bir düzenli ifade içermesi haricinde tamamen aynıdır. }
\paragraph{Belirli tekrar sayıları}{ parantezler içinde minimum ve maksimum tekrar sayılarını belirtebilirsiniz. “ab{2,4}” ifadesi “abb”,”abbb” ve “abbbb” ifadelerini temsil eder ama “ab” yada “abbbbbb” ifadelerini temsil etmez. Minimum ve maksimum sayıyı es geçebilirsiniz. Eğer minimum sayısı yoksa 0 kabul edilir, maksimum sayı yoksa  “sonsuz” kabul edilir.}
\paragraph{Geri-referans}{ “\textbackslash \textbackslash n” benzeri bir ifadeyle parantezli ifade olmaksızın girdinin bir bölümünün tekrarını gösterebilirsiniz. Düzenli ifade içindeki n, hayır anlamına gelir. Mesela “(ab)\textbackslash \textbackslash 1” ifadesi “abab” ile eşleşir. “(ab*a)x\textbackslash 1” ifadesi ise parantezler “abba” ile eşleşir ve tüm ifade “abbaxabba” ile eşleşir (başka hiçbirşeyle eşleşmez). Daha fazla ayrıntıyı GNU grep’in dökümanları içinde mevcuttur.}
\paragraph{Aç gözlü olmayan (eşleşme:}{
 “*” , “+” ve “?” operatörleri genellikle açgözlüdür. Onlar mümkün olduğunca çok sayıda girdiyle eşleşmeye çalışırlar: ”$ ^\wedge $a.*a” ifadesi “abacada” giriş stringine uygulanır. Sadece “aba” yada “abaca”ya uygulanamaz. Ancak açgözlü olmayan versiyonlarıda vardır. “*?” ,”+?” ve “??” açgözlü olmayan versiyonlara karşılık gelir. Bunlar mümkün olduğu kadar az girdiyle eşleşmeye çalışırlar. Büzüm örneğimizde “a.*?a” , “aba” ile eşleşebilir. Parantez operatörüde aç gözlü olmayan versiyonu sağlayabilir.}
 
Her program her uzantıyı desteklemez. Tablo 7.1 çok önemli programları kısaca gösterir. Emacs, Perl ve Tcl burada tartışılmayan bir çok uzantıyı destekler.
\end{subsection}
\end{section}
\begin{section}{Dosya içinde metin arama – grep}

Düzenli ifadeyi kullanan en önemli Linux programlarından biri grep’tir. Verilen düzenli ifade ile eşleşen metinleri dosya içindeki satırlarda arar. Eşleşen satırlar çıktı olarak verilir,eşleşmeyenler atılır.

Grep’in iki çeşidi vardır. Geleneksel olarak stripped-down fgrep (“sabit”) düzenli ifadelere izin vermez. Karakter stringlerine ayrılmıştır ama çok hızlıdır. egrep (“gelişmiş”) ek düzenli ifade operatörleri sunar ama çok daha yavaştır ve daha fazla hafızaya ihtiyaç duyar.

\paragraph{}{
\begin {table}[H]
\caption {Düzenli İfade Desteği} \label{tab:title} 
\begin{tabular}{c c c c c c c c}
\hline
Bir & Bir&Bir&Bir&Bir&Bir&Bir\\
\hline
Bir & Bir&Bir&Bir&Bir&Bir&Bir\\
\hline
\end{tabular}
\end {table}
}

\paragraph{}{
\begin {table}[H]
\caption {grep parametreleri} \label{tab:title} 
\begin{tabular}{c r l}
\hline
{} & Seçenek & Sonuç\\
\hline
-c &	(sayma)	&	eşleşen satırların sayısını verir.\\
-i	&(yoksayma)	&küçük büyük harfler eşittir.\\
-l	&(listeleme)&	eşleşen dosyaların isimlerini verir. Gerçek eşleşme değildir.\\
-n	&(sayı)&		çıktıdaki eşleşen satırların numaralarını verir.\\
-r	&(özyinelemeli)&	alt dizinlerdeki dosyalarıda arar.\\
-v&	(ters çevir)&	düzenli ifadeyle eşleşmeyen satırları verir.\\
\hline
\end{tabular}
\end {table}
}

Bu gözlemler bazı uzantılar için doğru olabilir. Özel olarak grep ve egrep düzenli ifade gelişimi için tamamiyle farklı algoritmalar kullanılır. Bu gelişim girdinin boyutuna aynı zamanda düzenli ifade yapısının boyutuna bağlı olarak performans sonuçlarını farklı şekilde elde etmeye çalışır. grep’in yaygın Linux dağıtımlarıyla birlikte 3 çeşidide gerçekte aynı programdır. Onlar arama şablonları için izin verdikleri söz dizimiyle ayrılırlar.

grep’in sözdizimi en az bir düzenli ifade gerektirir. Bu metin dosyasının veya dosyalarının isimleri tarafından takip edilir. Eğer hiçbir isim belirtilmemişse grep standart bir girdiye işaret eder (bölüm 8’e bakın).

Girdi içerisinde araştırmak için bir düzenli ifade bölüm 7.1’den temel düzenli ifadelerin yanında bölüm 7.1.1 deki gelişmiş düzenli ifadelerin çoğunuda taşıyabilir. grep’le “\textbackslash +”,”\textbackslash ?” ve “\textbackslash \{” operatörleri ters bölü tarafından takip edilmelidir. (egrep için bu gerekli değildir.) Malesef hiç aç gözlü olmayan operatör yoktur. 

Eğer kabuk arama şablonuna benzerse ve tek bir karakter stringinden daha karmaşıksa kabuğun düzenli ifadeyi genişletmeye çalışmasını önlemek için düzenli ifadeleri tek tırnak içine almalısınız.

Düzenli ifadeler ek olarak komut satırında çeşitli parametreler yazılabilir. (Tablo 7.2’ye bakın.)

-f (“dosya”) parametresiyle arama şablonu bir dosyadan okunmuş olabilir. Eğer dosya birden çok satır taşırsa her satırın içeriği onun kendi sağında eşzamanlı olarak araştırılmış bir arama olarak gözönüne alınacaktır. Bu arama şablonlarının sıklıkla kullanılabilmesi için özellikle düşünülmüş bişeydir. 
Bahsettiğimiz gibi fgrep arama şablonu olarak düzenli ifadeleri kullanmaz. egrep düzenli ifadeler için en uygun uzantıları mevcut duruma getirir (tablo 7.1).

Son olarak grep için bazı örnekler. frog.txt dosyası Kurbağa Kralın peri masalı Grimm Kardeşleri içerir. (ek bölüm B’ye bakın). frog karakter setini taşıyan tüm satırlar şu şekilde bulunur.
\begin{verbatim}
$ grep frog frog.txt
Frog stretching forth its big, ugly head from the water. >>Ah,old
>>Be quiet, and do not weep,<< answered the frog, >> I can help you, but
>>Whatever you will have, dear frog,<<said she,>>My clothes,my pearls
\end{verbatim}

Açıkça “frog” kelimesini (“bullfrog” veya “frogspawn” benzeri  varyasyonlarını bulmayacak) aramak için kelime ayıracı uzantısına ihtiyaç duyarsın).

\begin{verbatim}
$ grep \<frog\> frog.txt
frog stretching forth its big, ugly head from the water. >> Ah, old
\end{verbatim}

(Bu ingilizce olması farketmez. Dil ne olursa olsun “frog” geçen her satır gösterilir) frogla başlayan satırları göstermek için aşağıdaki komut yazılır.
\begin{verbatim}
$ grep ^frog  frog.txt
frog stretching forth its big, ugly head from the water. >> Ah, old
frog, that he had caused three iron bands to be laid roun his heart,
\end{verbatim}

Farklı bir örnek: “/usr/share/dict/words” dosyası ingilizce kelimelerin bir dosyasını içerir (sözlük olarak adlandırılır) 2. Burada 3 veya daha fazla “a”  içeren tüm kelimelerle ilgilenmekteyiz.

\begin{verbatim}
$ grep –n ‘a.*a.*a’ /usr/share/dict/words
8:aardvark
21:abaca
22:abacate
...
234831:zygomaticoaruricularis
234832:zygomaticofacial
234834:zygomaticomaxillary
\end{verbatim}

(sırasıyla): bir afrika hayvanı (orycteropus afer), iplik yapımında kullanılan muz (musa textilis), avokadonun Brezilyacası (perse sp.))
Daha karmaşık düzenli ifadelerle birlikte bir satır grep çıktısı çabucak kötü hale gelebilir. Bu –color parametresi kullanılarak bu karmaşıklık kesin olarak azaltılabilir. Bu da belirli renkler içerisinde bir dosyanın bölümlerindeki eşleşmeyi gösterebilir.
\begin{verbatim}
$ grep –color root /etc/passwd
root:x:0:0:root:/root:/bin/bash
\end{verbatim}

“export GREP\_OPTIONS='--color=auto' benzeri bir komut (örneğin $\sim$/.profile dosyası içinde) kalıcı bir temel üzerinde bu parametreyi kullanılabilir hale getirir; auto argümanı eğer çıktı bir boruya veya dosyaya gönderilirse rengi değiştirerek gösterir.
2.dağıtıma bağlı olarak sözlüğün boyutu değişebilir.

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item ”?” ve “+”  düzenli operatörleri gerçekten gerekli midir?
\item frog.txt içinde “king” veya ”king’s daughter” kelimelerini içeren satırları bulun.
\item “/etc/passwd” içinde sistem üstündeki kullanıcıların listesi vardır. Dosyanın her bir satırı kullanıcılar tarafından ayrılmış alanların bir sırasını içerir. Her satırdaki son alan kullanıcı için giriş kabuğu verir. Giriş kabuğu olarak bash kullanan bütün kullanıcıları listeleyen grep komut satırı yazın.
\item /usr/share/dict/words  5 sesli harfi “a”,”e”,”i”,”o” ve “u” sırasında taşıyan kelimeleri ara(sessiz harfler önünde ortasında veya sonunda olabilir.)
\item içinde 2 kez  enaz 4 harf içeren kelimelerin olduğu (”Frog King” gibi ) satırları bulun.
\end{itemize}}

\paragraph{Bu bölümdeki komutlar:}{
\paragraph{egrep}{belirli düzenli ifadelerle eşleşen satırlar için dosyaları arar. Gelişmiş düzenli ifadelere izin verir.}
\paragraph{fgrep}{belirli içerikle satırlar için dosyaları arar. Düzenli ifadelere izin yoktur.}
\paragraph{grep}{verilmiş düzenli ifadeyle eşleşen tüm satırlar için dosyaları arar.}
}

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Düzenli ifadeler karakter stringlerinin kümesini tanımlamak için çok güçlü bir metottur.
 \item grep ve onun ilişkisel araması düzenli ifadelerle eşleşen satırlar için bir dosyanın içerdiği aramadır.
\end{itemize}}

\end{section}

\chapter{Standart I/O and Filter Commands}
\chapter{More About the Shell}
\chapter{The File System}
\chapter{Dosyaları Arşivlemek ve Sıkıştırmak}
\paragraph{Amaçlar}
\begin{itemize}
 \item “Arşivleme” ve “Sıkıştırma” koşulların öğrenmek
 \item tar'ı kullanabiliyor olmak
 \item "gzip" ve "bzip2" kullanarak dosyaları sıkıştırmak ve açabiliyor olmak
 \item Dosyaları zip ve unzip ile işleyebilmek
 \end{itemize}
\paragraph{Önceden Bilinmesi Gerekenler}
\begin{itemize}
 \item Kabuk yöntemini kullanmak (Bölüm 4)
 \item Dosyalar ve dizinleri kullanmak (Bölüm 6)
 \item Filtreleri kullanmak (Bölüm 8)
 \end{itemize}

\begin{section}{Arşivleme ve Sıkıştırma}

“Arşivleme” birden fazla dosyayı toplayıp tek bir parça haline getirir. Tipik uygulamalar Manyetik kasete üzerinde bir dizin ağacı depolar. tape—the magnetic tape drive appears within Linux as a device file onto which the output of the archival program can be written. Diğer taraftan, arşivlenen verileri kasetin sürücü cihaz dosyalarından okuyup arşivden çıkartarak dizi ağaçlarını yeniden yapılandırabilir. İlgili programların çoğu, arşivleri
çözüp oluşturabildiğinden beri her iki işlemi de arşivleme başlığı altında inceliyoruz. 

Burada bizi ilgilendiren kısmı sadece kayıpsız sıkıştırmadır, sıkıştırılmış verilerimizi yeniden inşa ederek orijinal formuna sokabilmemizi sağlar.

Başka bir deyişle, yüksek dereceli bir sıkıştırmada gereksinimleri terk ederek orijinal haline getirmeyi başarabilmesi bir alternatiftir. Buna "Lossy" (kayıplı) sıkıştırma yöntemi denir  ve aynen JPEG resimleri ve "MPEG-1" ses katmanlarındaki gibi sıkıştırılırlar. Işin ilginç yanı olan gereksiz verilerden kurtulmanın yolu; Örnek bir mp3 verisini alalım, bu parcalarin bir kisim sinyallerini atalim, “psycho-acoustic model” e dayanarak sadece insanların duyabileceği derecede ve bunu dinleyenlerin anlayamayacağı kadar kayıp vererek kodlamak mümkündür. JPEG bir birlerine benzeyen çizgilerle çalışır.

Çalışma süresinin kodlanması aşağıdaki karakter dizinin temsil eden basit bir örnek alırsak;
\begin{verbatim}
ABBBBAACCCCCAAAABAAAAAC
\end{verbatim}

daha yoğun şekilde
\begin{verbatim}
A*4BAA*5C*4AB*5AC
\end{verbatim}

Burda, “*4B ” sıralı dört tane “B” karakter. Bu basit yaklaşım “run-length encoding”(uzun kodlama çalıştırma) olarak adlandırılır ve bugün bile örneğin faks makinelerinde(düzeltmeleriyle birlikte) bulunur. “Real” (gerçek) gzip veya bzip2 givi sıkıştırma yazılımları gelişmiş yeni metotlar kullanırlar.

Bu tur birleşmiş arşivleme ve sıkıştırma yazılımlar Windows dünyasında yenii ölçüde kullanırlar. (PKZIP, WinZIP vs), ayni adim genellikle Linux ve Unix dünyasında ayrı olarak ele alınır. Arşivi ilk kez kullanırken tar çıkış sıkıştırma işleminden önce tar ile dosyaların bir dizi olduğunu söylemek popüler bir yöntemdir, gzip-PKZIP ve benzerleri kendi üzerindeki her bir dosyayı sıkıştırır ve sonra bir tek büyük bir dosya içine sıkıştırılmış dosyaları toplar.

Bu yöntemin PKZIP ve bağlantılı yöntemlere göre avantajı bu yöntemin yüksek sıkıştırma oranı veren birkaç orijinal dosya arasında yer alabilmesidir. Ancak bu da şu durumda bir dezavantaj sayılabilir; eğer dosya hasar görmüşse tüm arşiv bu noktadan başlayarak işe yaramaz hale gelebilir.

Doğal olarak Linux’ta bile kimse sizi ilk sıkıştırmanızdan ve onları arşivlemenizden alıkoymaz. Maalesef bu yöntem diğerindeki kadar kullanışlı değildir

Elbette Linux’ta de Windows dünyasındaki rar ve zip gibi kullanışlı sıkıştırma programları vardır.
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Neden run-length kodlama örneğinde AA yerine *2A i kullanılır?
 \item run-length kodlama metodun kullanarak "A*2B****A" dizinini
nasıl gösterebilirsiniz?
\end{itemize}}
\end{section}

\begin{section}{tar Kullanarak Dosya Arşivlemek}

tar ismi “kaset arşivin ’den türemiştir. Uygulama bireysel dosyaları arşiv dosya sına koyar ve birinden diğerine ek bilgileri not alır (tarih, erişme izni, sahibi, …). Her ne kadar tar’ın başlangıçta manyetik teyp sürücüleri ile birlikte kullanılabilir olması gerekse de , tar arşivleri çeşitli medyalar üzerine doğrudan yazılmış da olabilir. Diğer kullanımlar arasında tar dosyaları Linux ve diğer özgür yazılım paketleri için kaynak kodu yaymak için standart biçimidir.

Linux üzerinde yaygın olarak kullanılan katran GNU uygulaması diğer Unix türevleri olan tar uygulamalarında bulunan çeşitli uzantıları içerir. Örneğin, GNU tar birçok medyayı kapsayan çok hacimli arşiv oluşturarak bunu destekler. Bu, çoklu cilt arşivler bile küçük arşivler yalnızca çok kirli Tabii ki, diskete yedek kopyalarını sağlar. Elbette ki sadece küçük arşivler için önemli olan bu çoklu cilt arşivleri bile diskete yedekleme yapılmasına izin verir.

Küçük bir açıklama: Bölme(split) komutu arşiv dosyaları gibi büyük dosyaları kesebilmeyi sağlar ve böylece dosya uygun parçalar haline getirilerek disketlere kopyalanabilir ya da e-maille yollanabilir ve cat(kedi) kullanılarak geldikleri şeklinde yeniden birleştirilebilirler.

tar’n avantajları: Bunun kullanımı basittir, güvenli ve iyi çalışır, evrensel olarak tüm Unix ve Linux sistemlerinde çalışır. Bunun dezavantajları basit arizalardan dolayı problemlere yol açabilir, ve  tar’ in tüm sürümleri aygıt dosyalarını depolayamayabilir. (Sisteminizin tümüne geri yüklemek istediğinizde).

tar arşivleri, dosyalar ve tüm dizin hiyerarşileri içerir. Eğer Windows medyası ağ üzerinden dizin ağaçları içinde takılı ise, içerikleri tar kullanarak arşivlenir. tar kullanılarak oluşturulan arşivler normalde sıkıştırılmamıştır, Ama başka sıkıştırma yazılımlar kullanarak sıkıştırılabilir (bugüne kadar her zaman gzip veya bzip2 kullanılmıştır). Bunlar yedek kopyalamalar ile ilgili iyi bir fikir değildir, sıkıştırılmış arşiv verilerin bit hatalar her zaman geri kalan verilerin kayıplarına yol acar. Typical suffixes for tar archives include .tar , .tar.bz2 , or .tar.gz , depending on whether they have been compressed not at all, using bzip2 , or using gzi . ".tgz" uzantısı zipped (sıkıştırılmış) tar veri formati genel olarak DOS dosya sistemi üzerinde depolanması gerekiyor. tar ’in söz dizimi;
\begin{verbatim}
tar <options> <file>||<directory> …
\end{verbatim}
önemli tar seçenekleri:

-c (“create”) yeni arşiv oluşturur

-f file $<$file$>$ üzerinden yeni arşiv oluşturur (veya mevcut arşivden okur),

$<$file$>$ düz dosyalarda veya bir aygıt dosyalarda bulunması (diğerlerinden yanı sira)

-M multi-volume arşivleri kullanmak

-r arşive dosyalar ekler (manyetik kaseteler için değil)

-t arşiv içindekileri görüntüler

-u arşiv içindeki kendi sürümünden daha yeni olan dosyalari değiştirir. Eğer dosyaların hepsi oluşmamışsa, bunlar daha önceden eklenmiştir (manyetik kaseteler için değil)

-v Verbose modulu—tam o sırada tar' ın ne yapıyor olduğunu görüntüler

-x Dosyalar ve Dizinleri arşivden çıkarır

-z gzip kullanarak arşivi sıkıştırır veya sıkıştırmadan çıkarmasını

-Z sıkıştırma kullanarak arşivi sıkıştırır veya açmasını (Normalde linux üzerinde mevcut değil)

-j bzip2 kullanarak arşivi sıkıştırır veya sıkıştırmadan çıkarmamasının
option syntax tar in söz dizim seçenekleri oldukça sıra dışıdır,

Bunda -f gibi parametre olanlar (olağanüstü) dâhil olmak üzere tekbir tire sonra birkaç seçenekleri "paketlemek" (başka bir yerde olduğu gibi) mümkündür.

İlk "seçenek paketi" önünde gösterişi çizgi dışarı bırakabilirsiniz. Sık sık aşağıdaki gibi komutları göreceksiniz:
\begin{verbatim}
tar cvf ...
\end{verbatim}
Yine de,  bunu önermiyoruz.

Aşağıdaki örnekte arşivler tüm dosyaları ile birlikte asil dizinde data isim ile devam eden data. tar dosyası kullanıcının ana sayfasında bulunmaktadır.
\begin{verbatim}
# tar -cvf ~/data.tar data* data1
data10
data2
data3
\end{verbatim}
-c seçeneği yeniden arşiv oluşturup düzenler, "-f ~/data.tar" isimli arşivin ismini verir. -v seçeneği sonucu hakkında hiçbir değişiklik yapamaz; sadece dosyaların isimleri hakkında arşivlenmiş halini ekranda görüntüler. (eğer dosyalardan birisi arşivlenmişe bu da gerçekten bir dizin ise, dizinin tüm bilgilerine arşivin içine dizinler eklenecektir.

Tar tüm bir dizinin arşivlenmesini de sağlar. Bunu çevreleyen dizinden yapmak daha iyidir. Arşivin içine bir altdizin oluşursa buda arşivi paketten çıkarırken yeniden oluşacaktır. Aşağıdaki örnekte daha detaylı olarak gösterecektir.
\begin{verbatim}
# cd /
# tar -cvf /tmp/home.tar /home
\end{verbatim}


Sistem yöneticisi root home.tar isimli /home dizininde bir arşiv depolarsa (tüm kullanıcı bilgileri). Bu da /tmp dizin içerisine saklanır.

Eğer dosyalar ve dizinlerin mutlak path isimlerin kullanarak verilirse, tar path
ismine bağlı otomatik olarak depolar (başka bir sözle "/" ile başlayan her bir
isimleri kaldırılmıştır ). Başka bir bilgisayarda arşivden paket çıkarırken bu tür
problemleri önler (Uygulama 11.6 ya bakın).

Arşivin "tablo içeriklerini" -t seçeneğin kullanarak görüntüleyebiliriz:
\begin{verbatim}
$ tar -tf data.tar data1
data10
data2
\end{verbatim}

-v seçeneği tar i daha detaylı verir:
\begin{verbatim}
$ tar -tvf data.tar
-rw-r--r-- joe/joe            7 2009-01-27 12:04 data1
-rw-r--r-- joe/joe            8 2009-01-27 12:04 data10
-rw-r--r-- joe/joe            7 2009-01-27 12:04 data2
\end{verbatim}

-x komutu ile verileri açabilirsiniz:
\begin{verbatim}
$ tar -xf data.tar
\end{verbatim}
bu durumda tar terminal üzerinde hiç çıktı üretmez. -v parametresini kullanmanız gerekir:
\begin{verbatim}
$ tar -xvf data.tar data1
data10
data2
\end{verbatim}

Eğer arşiv hiyerarşi bir dizin içerirse, bu ana dizini yeniden oluşturur. (Eğer hatırlarsanız tar tüm mutlak isimlerinden bir tane path islimine bağlı üretir.) Herhangi dizine arşivleri çıkartabilirsiniz, her zaman bu yapıyı tutar.

Paketi çıkarma sırasında dosya veya dizin isimlerini değiştirebilirsiniz. Bu durumda söz konusu olan sadece dosyalar ve dizinler paketten açılacaktır. Ancak, arşivin içindeki isimlerin tam olarak eşleşmesine dikkat edin:
\begin{verbatim}
$ tar -cf data.tar ./data 
$ tar -tvf data.tar
drwxr-xr-x joe/joe          0 2009-01-27 12:04 ./data/
-rw-r--r-- joe/joe          7 2009-01-27 12:04 ./data/data2

$ mkdir data-new                                 ./ missing
$ cd data-new
$ tar -xvf ../data.tar data/data2
tar: data/data2: Not found in archive
tar: Error exit delayed from previous errors
\end{verbatim}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Ana dizinizdeki dosyaların liste bilgilerin bir dosya içinde depolayın.
O dosyanın tar arşivini oluşturun. Orijinal dosya ve onun arşivini bir biriyle karşılaştır. Ne önerilirsiniz?
 \item Üç veya dört bos dosya oluşturup onu yeni oluşturduğunuz arşive ekleyiniz
 \item Asıl dosyanızı silin ve tar'ın içindekileri arşivden çıkartın.
 \item Eğer bir dosya veya muhafaza edilmesi için dizinin adı mutlak bir yol adı olarak verilirse neden GNU tar profilaktik olarak yol adı başlangıcında silmez? ve etc-backup.tar (a) mutlak yol isimleri varsa ne olacağını hayal edin,(b) başka bir bilgisayara aktarılır ve orada çözülür.
\end{itemize}}
\end{section}
\begin{section}{gzip ile Dosya Sıkıştırma}

Linux in en yaygın kullanılan sıkıştırma uygulaması Jean-Loup Gailly ve Mark Adler tarafından geliştirilmiştir. Bu tek bir dosya sıkıştırması için kullanılmıştır. (yakınlarda adı geçmiştir, çokça dosyaları tek arşivde içermesi mümkündür).

gzip uygulaması ("GNU zip" in kısaltılmışı) 1992 de sıkıştırma problemleri önlemek için ortaya çıkmıştır, standart Unix sürümlerin özel sıkıştırma aracısıdır. Sıkıştırma Lempel-Ziv-Wlch algoritmasına dayanmistir (LZW), patent hakları US tarafından saklıdır 4,558,302. Bu patenti Sperry (later Unisys) şirketine ait olup bu da 20 Haziran 2003 de süresi sona ermişti. Diğer taraftan, gzip DEFLATE metodu Phil Katz [RFC 1951] tarafindan  kullanılmıstır, artık LZW patentine sahip olmamasına dayalı bunun yanı sıra LZ77 isimin alan Huffmen scema kodlaması ozgur patent olmuştur. ayrıca, LZW den daha iyi çalışmaktadır.

gzip compress i kullanarak sıkıştırılmış dosyaları sıkıştırmadan çıkarır, çünkü
Sadece Unisys tarafından patenti korunmuştur. Bu tur dosyaları ".Z" komutu
İsimleri ile ayırt edebilirsiniz. 

gzip PKZIP ve benzer Windows uygulamaları "ZIP" ismiyle karıştırılmamalıdır. Bu tur uygulamalar derhal dosyaları sıkıştırıp ardından arşivleyebilir; gzip sadece sıkıştırma isiyle uğraşır ve arşivleme işini tar veya cpio uygulamalarına bırakır .—gzip, ZIP paketleri tam olarak hangi bir dosya DEFLATE yöntemle arşivlenmiş bunları arşivden çıkarabilir.

gzip bir tek dosyaları isler ve değiştirir, dosyaların uzantı isimlerine. gz ismini ekler. Bu degisikler dosyanın orijinal halinden daha az hafıza tutar. Birkaç dosya bir tek arşiv içine sıkıştırılmalıdır, tar ve gzip bileşik olmalıdır.

gzip in en önemli tercihleri şunlardır:

-c sıkıştırılmış dosyasını standart sıktıysa gönderir, asil dosyanın yerine konur;
asilin kalanı değişmemektir.

-d sıkıştırılmış dosyanı çıkarmak (öteki türlü: gunzip gzip -d gibi çalışır)

-l ("list") sıkıştırılmış dosyanın adi, paket boyutu gibi önemli bilgilerini görüntüler

-r (“recursive”) alt dizindeki dosyaları sıkıştırır

-S $<$suffix$>$ uses the specified suffix in place of .gz

-v her bir dosyanın isimi ve sıkıştırma oranının çıktılarını gösterir

-1 … -9 B ir bir sıkıştırma oranı belirtir -1 (or --fast ) Çok hızlı çalışır ama
iyi sıkıştırmaz, -9 ( ya da --best ) çok iyi sıkıştırır ama yavaş; varsayılan ayarları ise -6'dır.

Aşağıdaki komutu letter.tex dosyanı sıkıştırır, letter.tex.gz isimli sıkıştırılmış dosya depolar ve asıl dosyası silinir:
\begin{verbatim}
$ gzip letter.tex
\end{verbatim}
Dosyayı paketten çıkarırken
\begin{verbatim}
$ gzip -d letter.tex
\end{verbatim}
ya da
\begin{verbatim}
$ gunzip letter.tex
\end{verbatim}
letter.tex.gz (-S .t) yerine letter.tex.t olarak sıkıştırılmış dosya ve dosyanın sıkıştırma oranin ciktisi (-v):
\begin{verbatim}
$ gzip -vS .t letter.tex
\end{verbatim}
-s komutu sıkıştırmadan sikama üzerine belirtir, "gzip -d" olana kadar a .gz :
\begin{verbatim}
$ gzip -dS .t letter.tex
\end{verbatim}
Eğer tex uzantılı tum dosyaları all.tar.gz seklinde sıkıştırmak istersek, aşağıdaki komut kullanılır
\begin{verbatim}
$ tar -cvzf tex-all.tar.gz *.tex
\end{verbatim}
Unutmayın; tar asıl dosyayı silmez! Bu sadece paketten çıkarmak için kullanılır.
\begin{verbatim}
$ tar -xvzf tex-all.tar.gz
\end{verbatim}
\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Alıştırma 11.3 deki en iyi sıkıştırması ile tar arşivin sıkıştırın.
 \item Sıkıştırılmış arşivin içeriklerini denetlemek. tar arşivden asil yerine geri getirin.
 \item Nasıl bir şekilde ana dizininizdeki tüm içerikleri paketleyip gzip dosyasını sıkıştırır?
\end{itemize}}
\end{section}
\begin{section}{bzip2 ile Dosya Sıkıştırmak}

bzip2 Julian Seward tarafından geliştirilen büyük ölçüde gzip'e uyumlu bir uygulamadır. Ancak, bu başka yöntemler içinde kullanılır yüksek derece fazladan zaman ve hafıza kullanılarak sıkıştırır.  (sıkıştırmadan acarken de bir farkı yoktur).

bzip2 "Burrows-Wheeler dönüşümünü" kullanır kodlamada sik sik ortaya çıkan dizinleri tek karakteristik dizilere çevirir. Bu sonuçlar "local frequency" e tek karakteristik olarak sıralanır, çalışma uzunluğu hesaplandıktan sonra, Huffman semasina göre kodlanır. Huffmen kodu yoğun bir şekilde dosyaya yazılır.

Bzip'den ne haber? bzip aritmetiksel kodlama kullanan bzip2 ye göre daha önce çıkmış olup donuşumu Huffman kodlamasından sonra blokla mistir. Ancak, geliştiricisi aritmetiksel kodlamaya karar verdi bu nedenle onu çevreleyen uygulamalar çeşitli patent sorunlar yaşadı.

gzip,bzip2 ler sıkıştırmak için bir veya birden fazla dosya isimlerin parametre olarak kabul eden .bz2 uzantı isimle biten dosyalar, sıkıştırılmış sürümlerin yerine geçer.

-c ve -d seçenekleri eponymous seçeneklerine karsı gelip. Ancak, “seçeneklerin kalitesi” -1 den -9 a farklı çalışır: onlar o anki sıkıştırmanın kullanarak blok boyutun belirler. Varsayılan değeri 9 dur, -1 olunca önemli bir hız kazancı sunmaz.

-9 900kib boyutta bloklar. Bunun karşılığı hafıza kullanımı yaklaşık 3.7 MiB
Sıkıştırır (7.6 MiB sıkıştırır), çağdaş bir donamın sorun çıkarmamalıdır. Blok
Boyutlarının artırılmasından bir avantaj elde edilebilir gibi görünmüyor. Sıkıştırma üzerinde blok boyutu seçimini vurgulamakta yararı sıkıştırmadan çıkarmada gerekli olan hafıza miktar boyutunu belirler, aklınızda tutmanız gerekeni eğer çok az hafızalı bilgisayarda çok gibi byte bilgisayarla. bz2 dosya hazırlamada bzip2 (1) daha ayrıntılı olarak açıklar.

Karşılaştırdığınızda da gzip ve gunzip,bunzip2 dosyaları açmak için, bzip2 de dosyaları sıkıştırmak için kullanılır. (Bunlar gzip2 nin başka bir ismidir: Hem “bzip2 -d ” kullanarak ta dosyaları açabilirsiniz.)
\end{section}
\begin{section}{zip ve unzip kullanarak Dosya Arşivleme ve Sıkıştırmak}

Windows da veya internette veri alış verişte genellikle widespread ZIP dosya bicimi kullanılmalı (bugünlerde Windows üzerinde birçok dosya arşiv programları da .tar.gz ile uyumludur). Linux'da iki ayrı uygulama vardır zip (arşivleri oluşturma) ve unzip (arşivleri açma).

Dağıtıma baglı olarak bu uygulamaları ayrı ayrı kurmanız gerekir.
Debian GNU/Linux'da, örnegin, zip ve unzip iki ayrı paket bulunur.

Zip programının arşivleme tarzı size PKZIP gibi programların sıkıştırma tarzını
hatırlatabilir. En basit söylemle, komut satırına geçirilen dosyaları toplar:
\begin{verbatim}
$ zip test.zip file1 file2
adding: file1 (deflated 66%)
adding: file2 (deflated 62%)
$ _
\end{verbatim}

(Burada test.zip çıkan arşivin adıdır.)

-r seçeneğini kullanarak zip'e alt dizinlerin içine inmesi komutunu verebilirsiniz.:
\begin{verbatim}
$ zip -r test.zip ziptest
adding: ziptest/ (stored 0%)
adding: ziptest/testfile (deflated 62%)
adding: ziptest/file2 (deflated 62%)
adding: ziptest/file1 (deflated 66%)
\end{verbatim}

-@ seçeneğiyle zip kendi standartları çerçevesinde arşivlenecek dosyaların adlarını okur:
\begin{verbatim}
$ find ziptest | zip -@ test
adding: ziptest/ (stored 0%)
adding: ziptest/testfile (deflated 62%)
adding: ziptest/file2 (deflated 62%)
adding: ziptest/file1 (deflated 66%)
\end{verbatim}

(Arşiv dosyasının adında. zip son ekini kullanmayı unutabilirsiniz.)
zip bir arşive dosya eklemenin 2 yolunu bilir. Dosyayı sıkıştırma olmadan depolanmış kabul eder ve saklanır (sıkıştırılmış dosyanın yüzde kaç sıkıştırıldığını mesela "\% 62 düşürülmüş", arşiv içinde kendi orijinal dosyanın boyutu düşürülmüş iken sadece \%38 olduğu anlamına gelmektedir ). siz -0 seçeneğini kullanmadıkça zip otomatik olarak daha mantıklı bir yaklaşım seçer.

Eğer var olan bir zıp dosyasını onun ilk parametresiyle çağırır ve başka bir şey belirleyemezseniz, arşivlenecek dosyaların (aynı adları taşıyan mevcut dosyaların üzerine yazılmış olan) mevcut içeriğinin üstüne arşive eklenir. Bu durumda zıp, tar ve çipodan farklı davranır. Temiz bir arşivleme isterseniz ilk olarak dosyayı kaldırmanız gerekir.

Dosyaları aptalca eklemenin yanı sıra, zıp operasyonun diğer birkaç morlarını da destekler:  -u seçeneği arşivi komut satırında belirtilen dosyayla aynı ismi taşıyan bir dosya daha varsa sadece yeni olanı arşiv dosyalarına ekleyerek günceller(adı geçen dosyalar henüz arşive hiçbir şekilde alınmamışsa).-f seçeneği arşiv dosyalarını komut satırında üzerine yazılmış daha yeni versiyonlarıyla canlandırır(bütünüyle yeni dosyalar arşive eklenmez). -d seçeneği arşiv içindeki dosyaları siler ve kişilerin isimleri komut satırında dosya adlarını değerlendirir.

zıp'in yeni sürümleri aynı zamanda -FS (dosya senkronizasyon) modunu destekler. Bu mod -u'nun yaptığını yaparak arşivi dosya sistemine senkronize eder, fakat aynı zamanda komut satırı üzerindeki henüz isimlendirilmemiş dosyaları siler(ya da -r durumunda aranan bir dizinin parçasıdır). Bu metodun avantajı yeniden yapılandırılmış bir arşivinkiyle karşılaştırıldığında arşivde önceden var olan değişmemiş dosyaların tekrar sıkıştırılmış olmasını gerektirmez.

zip her çeşit seçeneği destekler ve "zip -h" yi kullanarak listeye bakabilirsiniz (ya da -h2'yi kullanarak daha ayrıntılı bir listeye bakabilirsiniz). Aynı zamanda zip(1) man sayfası da çok bilgilendiricidir.
zip her çeşit seçeneği destekler ve "zip -h" yi kullanarak listeye bakabilirsiniz (ya da -h2'yi kullanarak daha ayrıntılı bir listeye bakabilirsiniz). Aynı zamanda zip(1) man sayfası da çok bilgilendiricidir.
Arşivin için gözetmenin en iyi yolu -v seçeneğin kullanmak, içinde ne olduğunu gormek altdizinler için zorluk çıkarabilir.

\begin{verbatim}
Bu tablonun düzenlenmesi lazım

$ unzip -v test                  The.zip suffix maybe omitted
Archive: Length --------
0 16163 18092 35147 --------
69402
test.zip Method ------ Stored Defl:N Defl:N Defl:N
Size Cmpr ------- ---- 00% 6191 62% 6811 62% 12119 66% ------- ---
25121 64%
Date ---------- 2012-02-29 2012-02-29 2012-02-29 2012-02-29
Time CRC-32 ----- -------- 09:29 00000000 09:46 0d9df6ad 09:01 4e46f4a1 09:01 6677f57c
Name
----
ziptest/ ziptest/testfile ziptest/file2 ziptest/file1 -------
4 files
\end{verbatim}

unzip le arşivin ismini çağırması arşivi paketten açmasına karşılık gelir:
\begin{verbatim}
$ mv ziptest ziptest.orig 
$ unzip test
Archive: test.zip
    creating: ziptest/ 
  inflating: ziptest/testfile 
  inflating: ziptest/file2 
  inflating: ziptest/file1
\end{verbatim}
-d komutunu kullarak asıl dizinden başka bir dizin içine arşivi paketten açmak. Zorunlu kalsa bu dizin yeniden oluşturulur:
\begin{verbatim}
$ unzip -d dir test 
Archive: test.zip
    creating: dir/ziptest/ 
  inflating: dir/ziptest/testfile 
  inflating: dir/ziptest/file2 
  inflating: dir/ziptest/file1
\end{verbatim}

Eğer komut satırında belirli dosya isimi varsa, o zaman sadece bu dosyaları paketten çözülecektir:
\begin{verbatim}
$ rm -rf ziptest
$ unzip test ziptest/file1 
Archive: test.zip
   inflating: ziptest/file1
\end{verbatim}
(bu durumda ziptest dizini ine oluşacaktır)

Alternatif olarak, -x komutun kullanırsanız seçilmiş olan dosyalar haricindekiler paketten çözülmüş olacaklar:
\begin{verbatim}
$ rm -rf ziptest
$ unzip test -x ziptest/file1 
Archive: test.zip
  creating: ziptest/ 
 inflating: ziptest/testfile
 inflating: ziptest/file2
\end{verbatim}
Ayrıca kabuk arama desenleri kullanarak paketi çözebilirsiniz (veya paketten çözmektende önleyebilirsiniz) :
\begin{verbatim}
$ rm -rf ziptest
$ unzip test "ziptest/f*" 
Archive: test.zip
  inflating: ziptest/file2
  inflating: ziptest/file1 $ rm -rf ziptest
$ unzip test -x "*/t*" 
Archive: test.zip
    creating: ziptest/ 
  inflating: ziptest/file2 
  inflating: ziptest/file1
\end{verbatim}

(Note the quotes, which are used to hide the search patterns from the actual shell so unzip gets to see them.) Unlike in the shell, the search patterns refer to the complete file names (including any “/”).

As is to be expected, unzip also supports various other options. Look at the
program’s help information using “unzip -h” or “unzip -hh”, or read unzip(1).

\paragraph{Alıştırmalar}{
\begin{itemize}
 \item Ana dizinize birkaç dosya oluşturun ve onları zip le arşivleyin. "unzip -v" kullanarak arşivin içeriğine bak. /tm dizinine arşivi paketten çıkarın
 \item unzip kulanarak paketten çözüyor olduğunuz dosya eger dosya sistem içerisinde daha önceden oluşmuşsa ne olurdu?
 \item zip arşivi file.zip iki altdizinleri barındırıyor olsun bunların icinde (örnegin .c, .txt, .dat). Öyle bir unzip komutun verin ki içerikler icinden .txt dosyaların ayrı bir yerde açsın.
\end{itemize}}
\end{section}






\chapter{Introduction to System Administration}
\chapter{User Administration}
\chapter{Access Control}
\chapter{Linux Networking}

\end{document}